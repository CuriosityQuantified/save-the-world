<!doctype html>
<html lang="en" data-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Save the World?</title>
        <style>
            :root {
                /* Dark mode variables */
                --bg-color: #121212;
                --container-bg: #1e1e1e;
                --text-color: #e0e0e0;
                --heading-color: #ffffff;
                --accent-color: #64b5f6;
                --secondary-accent: #81c784;
                --error-color: #f44336;
                --border-color: #424242;
                --scenario-bg: #2d2d2d;
                --scenario-border: #64b5f6;
                --conclusion-bg: #263238;
                --conclusion-border: #2196f3;
                --button-bg: #4caf50;
                --button-hover: #45a049;
                --button-disabled: #2e2e2e;
                --history-bg: #333333;
                --form-bg: #2d2d2d;
                --code-bg: #1a1a1a;
                --log-header-bg: #333333;
                --toggle-bg: #555555;
                --toggle-active: #4caf50;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                max-width: 1000px;
                margin: 0 auto;
                padding: 20px;
                background-color: var(--bg-color);
                color: var(--text-color);
            }

            .container {
                background-color: var(--container-bg);
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            h1,
            h2,
            h3,
            h4 {
                color: var(--heading-color);
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
            }

            .header-container {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .header-container h1 {
                margin: 0;
            }

            .controls {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .switch {
                position: relative;
                display: inline-block;
                width: 60px;
                height: 30px;
            }

            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: var(--toggle-bg);
                transition: 0.4s;
                border-radius: 30px;
            }

            .slider:before {
                position: absolute;
                content: "";
                height: 22px;
                width: 22px;
                left: 4px;
                bottom: 4px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }

            input:checked + .slider {
                background-color: var(--toggle-active);
            }

            input:checked + .slider:before {
                transform: translateX(30px);
            }

            .toggle-label {
                font-size: 14px;
                font-weight: bold;
            }

            .scenario {
                margin-bottom: 20px;
                padding: 15px;
                background-color: var(--scenario-bg);
                border-radius: 5px;
                border-left: 5px solid var(--scenario-border);
            }

            .conclusion-scenario {
                margin-bottom: 20px;
                padding: 20px;
                background-color: var(--conclusion-bg);
                border-radius: 5px;
                border-left: 5px solid var(--conclusion-border);
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            }

            .conclusion-scenario h3 {
                color: var(--accent-color);
                margin-top: 0;
                text-align: center;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .grade-display {
                margin: 20px 0;
                padding: 15px;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                border-left: 5px solid var(--secondary-accent);
                text-align: center;
            }
            
            .grade-value {
                font-size: 1.5em;
                font-weight: bold;
                color: var(--secondary-accent);
            }
            
            .grade-explanation {
                font-style: italic;
                color: var(--text-color);
                margin-top: 10px;
            }
            
            .rationale-text {
                font-style: italic;
                color: var(--secondary-accent);
                margin: 15px 0;
                padding-left: 15px;
                border-left: 3px solid var(--accent-color);
            }

            .turn-counter {
                text-align: center;
                font-weight: bold;
                color: var(--accent-color);
                margin-bottom: 20px;
                font-size: 1.2em;
            }

            .media-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin: 20px 0;
                background-color: var(--scenario-bg);
                padding: 15px;
                border-radius: 5px;
            }

            video {
                max-width: 100%;
                border-radius: 5px;
                margin-bottom: 10px;
                background-color: #000;
            }

            audio {
                width: 100%;
                margin-bottom: 20px;
                background-color: var(--container-bg);
                border-radius: 20px;
            }

            .response-form {
                margin-top: 20px;
                background-color: var(--form-bg);
                padding: 15px;
                border-radius: 5px;
            }

            textarea {
                width: 100%;
                padding: 10px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                resize: vertical;
                min-height: 100px;
                background-color: var(--container-bg);
                color: var(--text-color);
            }

            button {
                display: inline-block;
                background-color: var(--button-bg);
                color: white;
                border: none;
                padding: 10px 15px;
                margin-top: 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                transition: background-color 0.2s;
            }

            button:hover {
                background-color: var(--button-hover);
            }

            button:disabled {
                background-color: var(--button-disabled);
                color: #777;
                cursor: not-allowed;
            }

            .loading {
                text-align: center;
                margin: 20px 0;
                color: var(--accent-color);
                padding: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                border-radius: 8px;
                max-width: 400px;
                margin: 20px auto;
            }

            .generation-progress {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-top: 15px;
                text-align: left;
                padding: 10px;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 5px;
            }
            
            .progress-item {
                display: flex;
                align-items: center;
                color: #999;
                font-size: 14px;
            }
            
            .progress-icon {
                display: inline-flex;
                justify-content: center;
                align-items: center;
                width: 24px;
                height: 24px;
                border-radius: 12px;
                margin-right: 10px;
                font-weight: bold;
                background-color: #333;
            }
            
            .progress-icon.complete {
                background-color: #004400;
                color: #00ff00;
            }
            
            .progress-icon.pending {
                color: #999;
            }
            
            .progress-label {
                flex-grow: 1;
            }
            
            .progress-status {
                font-size: 12px;
            }
            
            .progress-status.complete {
                color: #00ff00;
            }

            .history {
                margin-top: 30px;
                padding-top: 20px;
                border-top: 1px solid var(--border-color);
            }

            .history-item {
                margin-bottom: 15px;
                padding: 10px;
                background-color: var(--history-bg);
                border-radius: 4px;
            }

            .history-item h3 {
                margin-top: 0;
                color: var(--heading-color);
            }

            .history-turn {
                margin-bottom: 20px;
                padding: 15px;
                background-color: var(--history-bg);
                border-radius: 5px;
                border-left: 3px solid var(--accent-color);
            }

            .history-scenario {
                margin-bottom: 10px;
                padding: 10px;
                background-color: rgba(255, 255, 255, 0.05);
                border-radius: 4px;
            }

            .history-response {
                margin-top: 10px;
                padding: 0 10px;
            }

            .history-response h4 {
                color: var(--secondary-accent);
                margin-bottom: 5px;
            }

            .error {
                color: var(--error-color);
                background-color: rgba(244, 67, 54, 0.1);
                padding: 10px;
                border-radius: 4px;
                margin-bottom: 15px;
                display: none;
            }

            /* Developer Mode Styles */
            .developer-panel {
                margin-top: 15px;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                overflow: hidden;
                display: none;
            }

            .developer-header {
                background-color: var(--log-header-bg);
                padding: 10px 15px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .developer-header h4 {
                margin: 0;
                font-size: 14px;
                color: var(--accent-color);
            }

            .logs-container {
                padding: 0 15px;
                max-height: 500px;
                overflow-y: auto;
                background-color: var(--code-bg);
                display: none;
            }

            .log-entry {
                margin: 15px 0;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 15px;
            }

            .log-entry h5 {
                color: var(--accent-color);
                margin: 5px 0;
            }

            .log-entry pre {
                background-color: var(--container-bg);
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
                color: var(--text-color);
                font-size: 13px;
                margin: 5px 0;
            }

            .log-entry .prompt {
                border-left: 3px solid var(--secondary-accent);
            }

            .log-entry .completion {
                border-left: 3px solid var(--accent-color);
            }

            .log-entry .params {
                border-left: 3px solid var(--scenario-border);
                font-size: 12px;
            }

            .expand-arrow {
                transition: transform 0.3s;
            }

            .expanded .expand-arrow {
                transform: rotate(180deg);
            }

            .expanded + .logs-container {
                display: block;
            }

            .badge {
                display: inline-block;
                padding: 4px 8px;
                border-radius: 30px;
                font-size: 12px;
                font-weight: bold;
                background-color: var(--scenario-border);
                color: var(--container-bg);
            }

            .response-time {
                font-size: 0.9em;
                font-weight: bold;
                color: var(--secondary-accent);
                background-color: rgba(0, 0, 0, 0.2);
                padding: 2px 6px;
                border-radius: 4px;
                margin-left: 10px;
                display: inline-block;
            }

            .error-message {
                background-color: var(--error-color);
                color: white;
                padding: 10px;
                border-radius: 4px;
                margin: 10px 0;
                text-align: center;
                display: none;
            }

            .error-details {
                font-size: 10px;
                margin-top: 10px;
                padding: 8px;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
                overflow: auto;
                max-height: 150px;
                white-space: pre-wrap;
                font-family: monospace;
                text-align: left;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header-container">
                <h1>Save the World?</h1>
                <div class="controls">
                    <span class="toggle-label">Developer Mode</span>
                    <label class="switch">
                        <input type="checkbox" id="developer-mode-toggle" />
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div id="error" class="error"></div>

            <div id="loading" class="loading" style="display: none">
                <p>Loading simulation...</p>
                <div class="generation-progress" style="margin-top: 15px;">
                    <div class="progress-item">
                        <span class="progress-icon pending" id="scenario-progress-icon">...</span>
                        <span class="progress-label">Scenario Generated</span>
                        <span class="progress-status" id="scenario-progress-status">Pending</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-icon pending" id="videos-progress-icon">...</span>
                        <span class="progress-label">Videos Generated</span>
                        <span class="progress-status" id="videos-progress-status">Pending</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-icon pending" id="audio-progress-icon">...</span>
                        <span class="progress-label">Audio Generated</span>
                        <span class="progress-status" id="audio-progress-status">Pending</span>
                    </div>
                </div>
            </div>

            <div id="simulation-container" style="display: none">
                <div class="turn-counter">
                    Turn <span id="current-turn">1</span> of
                    <span id="max-turns">5</span>
                </div>

                <div class="scenario" id="current-scenario">
                    <p>Click "Generate Scenario" to begin.</p>
                </div>

                <div class="media-container">
                    <video id="scenario-video" controls style="display: none">
                        <source src="" type="video/mp4" />
                        Your browser does not support the video tag.
                    </video>
                    <video id="scenario-video-buffer" controls style="display: none">
                        <source src="" type="video/mp4" />
                        Your browser does not support the video tag.
                    </video>

                    <audio id="scenario-audio" style="display: none">
                        <source src="" type="audio/mpeg" />
                        Your browser does not support the audio tag.
                    </audio>
                </div>

                <div id="developer-logs"></div>

                <div class="response-form">
                    <textarea
                        id="user-response"
                        placeholder="How do you respond to this situation?"
                    ></textarea>
                    <div style="display: flex; justify-content: space-between">
                        <button id="start-btn">Generate Scenario</button>
                        <button id="submit-btn" disabled>
                            Submit Response
                        </button>
                    </div>
                </div>
            </div>

            <div id="history" class="history" style="display: none">
                <h2>Simulation History</h2>
                <div id="history-content"></div>
            </div>
        </div>

        <script>
            console.log("SCRIPT EXECUTION TEST AT TOP");
            // Global variables
            let simulationId = null;
            let wsConnection = null;
            let currentSimulation = null;
            let developerMode = false;

            // Variables for managing sequential video playback
            let currentVideoPlaylist = [];
            let currentVideoPlaybackIndex = 0;
            let actualUniqueUrlCount = 0;
            let hasAudioStarted = false; // Tracks if audio has been initiated by the user
            let isAudioPlaying = false; // Tracks if audio is currently playing

            // Video player elements for preloading
            const scenarioVideoElement = document.getElementById(
                "scenario-video",
            );
            const scenarioVideoBufferElement = document.getElementById(
                "scenario-video-buffer",
            );
            let currentPlayerElement = scenarioVideoElement;
            let bufferPlayerElement = scenarioVideoBufferElement;
            let isBufferVideoReady = false; // Track if buffer video is fully loaded and ready

            // DOM elements
            const errorElement = document.getElementById("error");
            const loadingElement = document.getElementById("loading");
            const simulationContainer = document.getElementById(
                "simulation-container",
            );
            const currentScenarioElement =
                document.getElementById("current-scenario");
            const currentTurnElement = document.getElementById("current-turn");
            const userResponseElement =
                document.getElementById("user-response");
            const startButton = document.getElementById("start-btn");
            const submitButton = document.getElementById("submit-btn");
            const historyElement = document.getElementById("history");
            const historyContentElement =
                document.getElementById("history-content");
            const scenarioAudioElement =
                document.getElementById("scenario-audio");
            const developerLogsElement =
                document.getElementById("developer-logs");
            const developerModeToggle = document.getElementById(
                "developer-mode-toggle",
            );

            // Event listeners
            startButton.addEventListener("click", startSimulation);
            submitButton.addEventListener("click", submitResponse);
            developerModeToggle.addEventListener("click", toggleDeveloperMode);

            // Initialize the UI
            function initUI() {
                simulationContainer.style.display = "block";
                startButton.disabled = false;
                submitButton.disabled = true;
                userResponseElement.value = "";

                // Ensure buffer is hidden and current player is correctly displayed (initially hidden until content)
                currentPlayerElement.style.display = "none";
                bufferPlayerElement.style.display = "none";

                // Check if there's a saved simulation in localStorage
                const savedSimulationId = localStorage.getItem("simulationId");
                if (savedSimulationId) {
                    loadSimulation(savedSimulationId);
                }
            }

            // Toggle developer mode
            async function toggleDeveloperMode() {
                developerMode = developerModeToggle.checked;

                if (simulationId) {
                    try {
                        const response = await fetch(
                            `/api/simulations/${simulationId}/developer-mode`,
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    enabled: developerMode,
                                }),
                            },
                        );

                        if (!response.ok) {
                            throw new Error(
                                `Error toggling developer mode: ${response.statusText}`,
                            );
                        }

                        // Update UI based on developer mode state
                        updateDeveloperModeUI();

                        // No need to update simulation here as WebSocket will handle it
                    } catch (error) {
                        showError(
                            `Failed to toggle developer mode: ${error.message}`,
                        );
                    }
                } else {
                    // Just update the UI if no simulation is active yet
                    updateDeveloperModeUI();
                }
            }

            // Update UI based on developer mode state
            function updateDeveloperModeUI() {
                // Show/hide developer logs based on mode
                const logEntries =
                    document.querySelectorAll(".developer-panel");
                logEntries.forEach((entry) => {
                    entry.style.display = developerMode ? "block" : "none";
                });
            }

            // Set up WebSocket connection for real-time updates
            function setupWebSocket() {
                // Close existing connection if any
                if (wsConnection) {
                    wsConnection.close();
                }

                // Create new WebSocket connection
                const protocol =
                    window.location.protocol === "https:" ? "wss:" : "ws:";
                const wsUrl = `${protocol}//${window.location.host}/api/ws/simulations/${simulationId}`;
                wsConnection = new WebSocket(wsUrl);

                // Set up event handlers
                wsConnection.onopen = () => {
                    console.log("WebSocket connection established");
                };

                wsConnection.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log("WebSocket message received:", message);

                    if (
                        message.type === "simulation_state" ||
                        message.type === "simulation_updated"
                    ) {
                        updateSimulationUI(message.simulation);
                        // Once the main simulation state is updated, we can hide the loading spinner.
                        // Ensure this happens after any potential progress checkmarks have appeared.
                        setTimeout(() => {
                            loadingElement.style.display = "none";
                        }, 1000); // Add a small delay to allow users to see final checkmarks
                    } else if (message.type === "progress_update") {
                        console.log(`Progress update received for step: ${message.step}`);
                        if (message.step === "scenario_generated") {
                            markProgressComplete("scenario");
                        } else if (message.step === "videos_generated") {
                            markProgressComplete("videos");
                        } else if (message.step === "audio_generated") {
                            markProgressComplete("audio");
                        }
                        // Keep loading visible until simulation_state or simulation_updated is received
                    }
                };

                wsConnection.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    // Consider hiding loading on critical WebSocket errors if simulation cannot proceed
                    // loadingElement.style.display = "none"; 
                };

                wsConnection.onclose = () => {
                    console.log("WebSocket connection closed");
                    // Try to reconnect after a delay
                    setTimeout(() => {
                        if (simulationId) {
                            setupWebSocket();
                        }
                    }, 3000);
                };
            }

            // Start a new simulation
            async function startSimulation() {
                // Clear any existing content
                currentScenarioElement.innerHTML =
                    "<p>Generating scenario...</p>";
                historyElement.style.display = "none";
                historyContentElement.innerHTML = "";
                developerLogsElement.innerHTML = "";

                // Disable the start button and show loading state
                startButton.disabled = true;
                loadingElement.style.display = "block";
                
                // Reset progress indicators
                resetProgressIndicators();

                // Reset audio flags
                hasAudioStarted = false; 
                isAudioPlaying = false;
                currentVideoPlaybackIndex = 0; // Reset for the new simulation

                try {
                    // Create a new simulation
                    const response = await fetch("/api/simulations", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            initial_prompt: "",
                            developer_mode: developerMode,
                        }),
                    });

                    if (!response.ok) {
                        throw new Error(
                            `Error creating simulation: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();
                    simulationId = simulation.simulation_id;

                    // Scenario progress will be marked by WebSocket message "scenario_generated"

                    // Save simulation ID to localStorage
                    localStorage.setItem("simulationId", simulationId);

                    // Set up WebSocket connection - this will handle subsequent progress updates
                    setupWebSocket();

                    // UI will be updated by "simulation_state" or "simulation_updated" message
                    // Loading spinner will be hidden by WebSocket message handler too.

                    // Initial state updates (non-progress related) for the new simulation
                    hasAudioStarted = false; 
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0; 
                    actualUniqueUrlCount = 0;
                    currentPlayerElement = scenarioVideoElement;
                    bufferPlayerElement = scenarioVideoBufferElement;
                    console.log("[UI Update] Reset currentPlayerElement to scenarioVideoElement for new turn media.");

                } catch (error) {
                    showError(`Failed to start simulation: ${error.message}`);
                    startButton.disabled = false;
                    loadingElement.style.display = "none"; // Hide loading on error
                }
            }

            // Load an existing simulation
            async function loadSimulation(id) {
                // Show loading state
                loadingElement.style.display = "block";
                
                // Reset progress indicators
                resetProgressIndicators();

                try {
                    // Get the simulation
                    const response = await fetch(`/api/simulations/${id}`);

                    if (!response.ok) {
                        // If not found, clear localStorage and reset UI
                        if (response.status === 404) {
                            localStorage.removeItem("simulationId");
                            loadingElement.style.display = "none";
                            return;
                        }
                        throw new Error(
                            `Error loading simulation: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();
                    simulationId = simulation.simulation_id;

                    // Set developer mode toggle based on simulation state
                    developerMode = simulation.developer_mode;
                    developerModeToggle.checked = developerMode;

                    // Set up WebSocket connection - this will handle progress and state updates
                    setupWebSocket();

                    // Scenario progress will be marked by WebSocket message "scenario_generated"
                    // Video/Audio progress will also be marked by WebSocket messages.

                    // Initial state updates (non-progress related) for the loaded simulation
                    hasAudioStarted = false; 
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0; 
                    actualUniqueUrlCount = 0;
                    currentPlayerElement = scenarioVideoElement;
                    bufferPlayerElement = scenarioVideoBufferElement;
                    console.log("[UI Update] Reset currentPlayerElement to scenarioVideoElement for new turn media.");

                    // The updateSimulationUI and hiding of loadingElement will be handled by WebSocket messages.
                } catch (error) {
                    showError(`Failed to load simulation: ${error.message}`);
                    localStorage.removeItem("simulationId");
                    loadingElement.style.display = "none"; // Hide loading on error
                }
            }

            // Submit user response to the current scenario
            async function submitResponse() {
                // Get user response
                const responseText = userResponseElement.value.trim();
                if (!responseText) {
                    showError("Please enter a response before submitting.");
                    return;
                }

                // Disable the submit button and show loading state
                submitButton.disabled = true;
                loadingElement.style.display = "block";

                try {
                    // Submit the response to the API
                    const response = await fetch(
                        `/api/simulations/${simulationId}/respond`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                response_text: responseText,
                            }),
                        },
                    );

                    if (!response.ok) {
                        throw new Error(
                            `Error submitting response: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();

                    // Update the UI with the updated simulation
                    updateSimulationUI(simulation);

                    // Clear the response input
                    userResponseElement.value = "";

                    // Hide loading state
                    loadingElement.style.display = "none";
                } catch (error) {
                    console.error("Response submission error:", error);
                    showError(`Failed to submit response: ${error.message}`);

                    // Try to recover the UI state
                    try {
                        // Get the current simulation state to recover
                        const getResponse = await fetch(
                            `/api/simulations/${simulationId}`,
                        );
                        if (getResponse.ok) {
                            const updatedSimulation = await getResponse.json();
                            updateSimulationUI(updatedSimulation);
                            showError(
                                "Your response was saved, but there was an error generating the next scenario. Please continue.",
                            );
                        }
                    } catch (recoveryError) {
                        console.error("Recovery error:", recoveryError);
                    }

                    submitButton.disabled = false;
                    loadingElement.style.display = "none";
                }
            }

            // Update UI with simulation data
            function updateSimulationUI(simulation) {
                console.log(
                    "[UI Update] Received simulation data:",
                    JSON.parse(JSON.stringify(simulation)),
                ); // Log incoming simulation object
                // Save the simulation
                currentSimulation = simulation;

                // Update turn counter
                currentTurnElement.textContent = simulation.current_turn_number;
                document.getElementById("max-turns").textContent =
                    simulation.max_turns;

                // Get the current turn
                const currentTurn = simulation.turns.find(
                    (t) => t.turn_number === simulation.current_turn_number,
                );

                // Update scenario display
                if (currentTurn && currentTurn.selected_scenario) {
                    // We no longer mark progress here as it's handled by delayed sequence above
                    
                    // Handle final turn differently (conclusion)
                    if (
                        simulation.current_turn_number === simulation.max_turns
                    ) {
                        currentScenarioElement.className =
                            "conclusion-scenario";
                        currentScenarioElement.innerHTML = `
                        <h3>Conclusion</h3>
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        <p class="rationale-text">${currentTurn.selected_scenario.rationale || ""}</p>
                        <div class="grade-display">
                            <h4>Final Grade: <span class="grade-value">${currentTurn.selected_scenario.grade || 70}/100</span></h4>
                            <p class="grade-explanation">${currentTurn.selected_scenario.grade_explanation || "Your performance was adequate but with room for improvement in addressing the absurd physics of the situation."}</p>
                        </div>
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    } else if (simulation.current_turn_number === 1) {
                        // Turn 1: Show situation_description + user_role + user_prompt
                        currentScenarioElement.className = "scenario";
                        currentScenarioElement.innerHTML = `
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        ${
                            currentTurn.selected_scenario.user_role &&
                            currentTurn.selected_scenario.user_prompt
                                ? `<p><strong>${currentTurn.selected_scenario.user_role}</strong> ${currentTurn.selected_scenario.user_prompt}</p>`
                                : currentTurn.selected_scenario.user_role
                                  ? `<p><strong>${currentTurn.selected_scenario.user_role}</strong></p>`
                                  : currentTurn.selected_scenario.user_prompt
                                    ? `<p>${currentTurn.selected_scenario.user_prompt}</p>`
                                    : ""
                        }
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    } else {
                        // Middle turns: Show only situation_description + user_prompt
                        currentScenarioElement.className = "scenario";
                        currentScenarioElement.innerHTML = `
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        ${
                            currentTurn.selected_scenario.user_prompt
                                ? `<p>${currentTurn.selected_scenario.user_prompt}</p>`
                                : ""
                        }
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    }

                    // Update media
                    console.log(
                        "[UI Update] Current turn object:",
                        JSON.parse(JSON.stringify(currentTurn)),
                    ); 
                    console.log(
                        "[UI Update] Checking currentTurn.video_urls:",
                        currentTurn.video_urls,
                    );

                    // Reset audio state for new turn media
                    hasAudioStarted = false;
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0; // Reset for new playlist for this turn
                    actualUniqueUrlCount = 0;

                    if (
                        currentTurn.video_urls &&
                        Array.isArray(currentTurn.video_urls) &&
                        currentTurn.video_urls.length > 0
                    ) {
                        // Progress marking is now handled in the delayed sequence above
                        
                        console.log(
                            "[UI Update] video_urls is a non-empty array. Processing...",
                        );
                        const processedUrlsFromTurn = [];
                        currentTurn.video_urls.forEach((url) => {
                            if (url && typeof url === "string") {
                                processedUrlsFromTurn.push(url);
                            }
                        });

                        // Ensure we only use unique URLs for the two-pass playlist
                        const actualUniqueUrls = [...new Set(processedUrlsFromTurn)];
                        console.log("[UI Update] Actual unique URLs for playlist:", actualUniqueUrls);

                        // Create the playlist: just use the unique sequence without repeating
                        currentVideoPlaylist = [...actualUniqueUrls];
                        actualUniqueUrlCount = actualUniqueUrls.length; // Store count of unique videos

                        console.log(
                            "[UI Update] Generated video playlist (Corrected Order):",
                            currentVideoPlaylist,
                        );
                        currentVideoPlaybackIndex = 0; // Reset index

                        if (currentVideoPlaylist.length > 0) {
                            console.log(
                                "[UI Update] Playlist has videos. Initializing playback.",
                            );
                            // Initial setup: currentPlayer is visible, buffer is hidden
                            currentPlayerElement.style.display = "block";
                            bufferPlayerElement.style.display = "none";
                            startOrContinuePlayback(); // Start playing the first video & preload next
                        } else {
                            console.log(
                                "[UI Update] Playlist is empty after processing. Hiding players.",
                            );
                            currentPlayerElement.style.display = "none";
                            bufferPlayerElement.style.display = "none";
                        }
                    } else {
                        // Progress marking is now handled in the delayed sequence above
                        
                        console.log(
                            "[UI Update] video_urls is NOT a valid non-empty array. Hiding video player.",
                        );
                        console.log(
                            "[UI Update] Value of currentTurn.video_urls:",
                            currentTurn.video_urls,
                        );
                        console.log(
                            "[UI Update] Is Array?",
                            Array.isArray(currentTurn.video_urls),
                        );
                        if (currentTurn.video_urls)
                            console.log(
                                "[UI Update] Length:",
                                currentTurn.video_urls.length,
                            );
                        scenarioVideoElement.style.display = "none"; // No valid videos in the list
                        currentVideoPlaylist = []; // Clear playlist if no videos are provided
                        currentVideoPlaybackIndex = 0;
                        // Also hide buffer player if no videos
                        scenarioVideoBufferElement.style.display = "none";
                    }

                    if (currentTurn.audio_url) {
                        // Progress marking is now handled in the delayed sequence above
                        
                        console.log("[UI Update] Received audio_url:", currentTurn.audio_url);
                        scenarioAudioElement.querySelector("source").src =
                            currentTurn.audio_url;
                        scenarioAudioElement.load();
                        // scenarioAudioElement.style.display = "block"; // No longer needed, audio is invisible
                    } else {
                        // Progress marking is now handled in the delayed sequence above
                        
                        console.log("[UI Update] No audio_url received for this turn.");
                        scenarioAudioElement.querySelector("source").src = "";
                        scenarioAudioElement.load();
                        // scenarioAudioElement.style.display = "none"; // Already default or handled by CSS if we add it
                    }

                    // Update buttons
                    submitButton.disabled =
                        Boolean(currentTurn.user_response) ||
                        simulation.is_complete;
                    startButton.textContent = simulation.is_complete
                        ? "Start New Simulation"
                        : "Restart Simulation";
                    startButton.disabled = false;

                    // Update developer logs if developer mode is enabled
                    if (
                        currentTurn.llm_logs &&
                        currentTurn.llm_logs.length > 0
                    ) {
                        renderDeveloperLogs(
                            currentTurn.llm_logs,
                            currentTurn.turn_number,
                        );
                    }
                } else {
                    // No scenario selected yet
                    currentScenarioElement.className = "scenario";
                    currentScenarioElement.innerHTML =
                        "<p>Waiting for scenario generation...</p>";
                    submitButton.disabled = true;
                }

                // Update history
                if (simulation.turns.length > 0) {
                    historyElement.style.display = "block";
                    historyContentElement.innerHTML = "";

                    // Sort turns by turn number
                    const sortedTurns = [...simulation.turns].sort(
                        (a, b) => a.turn_number - b.turn_number,
                    );

                    // Skip the current turn
                    const historyTurns = sortedTurns.filter(
                        (t) => t.turn_number < simulation.current_turn_number,
                    );

                    if (historyTurns.length > 0) {
                        historyTurns.forEach((turn) => {
                            if (turn.selected_scenario && turn.user_response) {
                                const turnElement =
                                    document.createElement("div");
                                turnElement.className = "history-turn";
                                turnElement.innerHTML = `
                                <h3>Turn ${turn.turn_number}</h3>
                                <div class="history-scenario">
                                    <p>${turn.selected_scenario.situation_description}</p>
                                    ${
                                        turn.selected_scenario.user_role &&
                                        turn.selected_scenario.user_prompt
                                            ? `<p><strong>${turn.selected_scenario.user_role}</strong> ${turn.selected_scenario.user_prompt}</p>`
                                            : turn.selected_scenario.user_role
                                              ? `<p><strong>${turn.selected_scenario.user_role}</strong></p>`
                                              : turn.selected_scenario
                                                      .user_prompt
                                                ? `<p>${turn.selected_scenario.user_prompt}</p>`
                                                : ""
                                    }
                                </div>
                                <div class="history-response">
                                    <h4>Your Response:</h4>
                                    <p>${turn.user_response ? turn.user_response.response_text : "No response recorded"}</p>
                                </div>
                            `;
                                historyContentElement.appendChild(turnElement);
                            }
                        });
                    } else {
                        historyElement.style.display = "none";
                    }
                } else {
                    historyElement.style.display = "none";
                }

                // Update developer mode UI
                developerModeToggle.checked = simulation.developer_mode;
                developerMode = simulation.developer_mode;
                updateDeveloperModeUI();
            }

            // --- NEW FUNCTION FOR SEQUENTIAL VIDEO PLAYBACK ---
            function playNextVideoInSequence() {
                if (currentVideoPlaybackIndex < currentVideoPlaylist.length) {
                    const videoUrl =
                        currentVideoPlaylist[currentVideoPlaybackIndex];
                    console.log(
                        `Loading video ${currentVideoPlaybackIndex + 1}/${currentVideoPlaylist.length} into current player: ${videoUrl}`,
                    );
                    loadVideoIntoPlayer(currentPlayerElement, videoUrl);

                    // Preload the next video into the buffer player
                    if (currentVideoPlaybackIndex + 1 < currentVideoPlaylist.length) {
                        const nextVideoUrl = currentVideoPlaylist[currentVideoPlaybackIndex + 1];
                        console.log(
                            `Preloading video ${currentVideoPlaybackIndex + 2}/${currentVideoPlaylist.length} into buffer player: ${nextVideoUrl}`,
                        );
                        loadVideoIntoPlayer(bufferPlayerElement, nextVideoUrl);
                    }

                } else {
                    console.log("Finished playing all videos in the playlist.");
                    currentPlayerElement.style.display = "none"; // Hide current player
                    bufferPlayerElement.style.display = "none"; // Hide buffer player
                    if (scenarioAudioElement.src && !scenarioAudioElement.paused) {
                        scenarioAudioElement.pause(); 
                    }
                }
            }
            
            function loadVideoIntoPlayer(playerElement, videoUrl) {
                if (!playerElement || !videoUrl) return;
                
                // Before changing source, remove any existing event listeners to prevent memory leaks
                playerElement.oncanplay = null;
                
                playerElement.querySelector("source").src = videoUrl;
                playerElement.load(); // Important: load the new source
                
                // Add event listener to track when the video is ready to play
                if (playerElement === bufferPlayerElement) {
                    playerElement.oncanplay = function() {
                        isBufferVideoReady = true;
                        console.log(`Buffer video (${videoUrl}) is ready to play`);
                    };
                }
                
                console.log(`Loaded ${videoUrl} into ${playerElement.id}`);
            }

            function startOrContinuePlayback() {
                if (currentVideoPlaybackIndex < currentVideoPlaylist.length) {
                    const videoUrl = currentVideoPlaylist[currentVideoPlaybackIndex];
                    console.log(
                        `Loading video ${currentVideoPlaybackIndex + 1}/${currentVideoPlaylist.length} into current player (${currentPlayerElement.id}): ${videoUrl}`,
                    );
                    loadVideoIntoPlayer(currentPlayerElement, videoUrl);
                    // The 'canplay' event on currentPlayerElement will trigger play and audio sync

                    // Preload the next video into the buffer player right away
                    const nextVideoIndex = (currentVideoPlaybackIndex + 1) % currentVideoPlaylist.length;
                    const nextVideoUrl = currentVideoPlaylist[nextVideoIndex];
                    console.log(
                        `Preloading video ${nextVideoIndex + 1}/${currentVideoPlaylist.length} into buffer player (${bufferPlayerElement.id}): ${nextVideoUrl}`,
                    );
                    isBufferVideoReady = false; // Reset buffer readiness flag
                    loadVideoIntoPlayer(bufferPlayerElement, nextVideoUrl);
                } else {
                    console.log("Finished playing all videos in the playlist sequence.");
                    // Keep the video player visible, just pause it
                    if (currentPlayerElement && !currentPlayerElement.paused) {
                        currentPlayerElement.pause();
                    }
                    if (scenarioAudioElement.src && !scenarioAudioElement.paused) {
                        scenarioAudioElement.pause();
                    }
                }
            }

            function handleVideoEndAndSwap() {
                console.log(`Video in ${currentPlayerElement.id} ended. Index: ${currentVideoPlaybackIndex}`);
                
                // Only proceed if the buffer video is ready
                if (!isBufferVideoReady) {
                    console.log("Buffer video not ready yet, waiting...");
                    // Set a timeout to check again, but not too long to avoid noticeable pause
                    setTimeout(checkBufferAndSwap, 20);
                    return;
                }
                
                // Buffer is ready, proceed with the swap
                performSwap();
            }

            // Separate function to check buffer readiness and perform swap
            function checkBufferAndSwap() {
                if (isBufferVideoReady) {
                    console.log("Buffer video is now ready, performing swap.");
                    performSwap();
                } else {
                    console.log("Buffer still not ready, checking again...");
                    setTimeout(checkBufferAndSwap, 20);
                }
            }

            // Function to perform the actual swap once buffer is ready
            function performSwap() {
                currentVideoPlaybackIndex++;
                
                // Reset the index if we've reached the end of playlist, creating a loop
                if (currentVideoPlaybackIndex >= currentVideoPlaylist.length) {
                    console.log("Reached end of playlist, looping back to beginning");
                    currentVideoPlaybackIndex = 0;
                }
                
                console.log("Swapping players.");
                // Swap players
                let temp = currentPlayerElement;
                currentPlayerElement = bufferPlayerElement;
                bufferPlayerElement = temp;
                
                // Update visibility
                currentPlayerElement.style.display = "block"; // Make new current player visible
                bufferPlayerElement.style.display = "none";  // Hide new buffer player (it was the old current)
                
                // Play the new current player immediately
                attemptPlayAndSyncAudio(currentPlayerElement);
                
                // Start preloading the next video immediately for the next swap
                const nextVideoIndex = (currentVideoPlaybackIndex + 1) % currentVideoPlaylist.length;
                const nextVideoUrl = currentVideoPlaylist[nextVideoIndex];
                console.log(
                    `Preloading next video for index ${nextVideoIndex} into buffer player (${bufferPlayerElement.id}): ${nextVideoUrl}`,
                );
                isBufferVideoReady = false; // Reset buffer readiness flag
                loadVideoIntoPlayer(bufferPlayerElement, nextVideoUrl);
            }

            // Add event listener to preload video when it's halfway through playback
            [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.addEventListener("timeupdate", () => {
                    // Only act if this is the currentPlayerElement
                    if (player === currentPlayerElement) {
                        // If we're halfway through the video, ensure buffer video is loading
                        if (player.currentTime >= player.duration * 0.5 && !isBufferVideoReady) {
                            console.log("Current video at halfway point, checking buffer status...");
                            if (bufferPlayerElement.readyState < HTMLMediaElement.HAVE_FUTURE_DATA) {
                                console.log("Buffer video not fully loaded yet, ensuring it's loading...");
                                const nextVideoIndex = (currentVideoPlaybackIndex + 1) % currentVideoPlaylist.length;
                                const nextVideoUrl = currentVideoPlaylist[nextVideoIndex];
                                loadVideoIntoPlayer(bufferPlayerElement, nextVideoUrl);
                            }
                        }
                    }
                });
            });

            // Universal 'ended' event listener for both video players
            [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.addEventListener("ended", () => {
                    // Only act if the event is from the currentPlayerElement
                    if (player === currentPlayerElement) {
                        handleVideoEndAndSwap();
                    }
                });
            });

            function attemptPlayAndSyncAudio(videoElementToPlay) {
                 videoElementToPlay.play().then(() => {
                    console.log(`Video ${videoElementToPlay.id} started playing.`);
                    // Audio starting logic is now primarily in syncAudioPlay (onplay event)
                    // This function might still resume audio if video was paused and played by JS.
                    if (scenarioAudioElement.src && hasAudioStarted && scenarioAudioElement.paused && isAudioPlaying === false) {
                        // If audio was previously started and is paused, and video is now playing, resume audio.
                        // This handles cases where JS might programmatically play the video after a pause.
                        console.log("attemptPlayAndSyncAudio: Resuming previously started and paused audio.");
                        scenarioAudioElement.play().catch(e => console.error("Error resuming audio in attemptPlayAndSyncAudio:", e));
                        isAudioPlaying = true;
                    }
                 }).catch(e => {
                    console.error(`Error trying to play video ${videoElementToPlay.id}:`, e);
                });
            }
            
            function attemptPlayVideo(videoElementToPlay) {
                videoElementToPlay.play().then(() => {
                    console.log(`Video ${videoElementToPlay.id} started playing (or resumed via attemptPlayVideo).`);
                }).catch(e => {
                    console.error(`Error trying to play video ${videoElementToPlay.id} via attemptPlayVideo:`, e);
                });
            }

            // Universal 'canplay' event listener
             [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.addEventListener("canplay", () => {
                    console.log(`Video in ${player.id} can play. Current playback index: ${currentVideoPlaybackIndex}, hasAudioStarted: ${hasAudioStarted}`);
                    if (player === currentPlayerElement) {
                        console.log(`${player.id} is current player and can play.`);
                        // If it's not the very first video OR if audio has already been started by the user, then auto-play.
                        // The first video (index 0) requires user to click play on the video controls itself.
                        if (currentVideoPlaybackIndex > 0 || hasAudioStarted) {
                             console.log(`Attempting to auto-play subsequent video or continue playing sequence via canplay.`);
                             attemptPlayVideo(player); // Auto-play subsequent videos or if sequence already started
                        } else {
                            console.log("First video is ready. Waiting for user to click play on video controls to start audio and video.");
                        }
                    } else if (player === bufferPlayerElement) {
                        console.log(`${player.id} is buffer player and can play. Ready for preloading.`);
                    }
                });
            });
            
            // Synchronization for manual video controls (if ever enabled) or seeking
            // These need to operate on the currentPlayerElement
            function syncAudioPlay() {
                console.log(
                    `syncAudioPlay triggered. hasAudioStarted: ${hasAudioStarted}, isAudioPlaying: ${isAudioPlaying}, audio.currentSrc: ${scenarioAudioElement.currentSrc ? scenarioAudioElement.currentSrc.substring(scenarioAudioElement.currentSrc.length - 30) : 'null/empty'}, audio.readyState: ${scenarioAudioElement.readyState}, player: ${currentPlayerElement.id}, player.paused: ${currentPlayerElement.paused}`
                );
                if (scenarioAudioElement.currentSrc && currentPlayerElement && !currentPlayerElement.paused) {
                    if (!hasAudioStarted) {
                        console.log("syncAudioPlay: Starting audio for the first time.");
                        scenarioAudioElement.currentTime = 0; // Start audio from the beginning
                        scenarioAudioElement.play().then(() => {
                            hasAudioStarted = true;
                            isAudioPlaying = true;
                            console.log("Audio started successfully via onplay (first time).");
                        }).catch(e => console.error("Error starting audio via onplay (first time):", e));
                    } else if (hasAudioStarted && scenarioAudioElement.paused) {
                        // If audio has started before and is now paused (e.g., user paused video then played), resume audio
                        console.log("syncAudioPlay: Resuming paused audio.");
                        scenarioAudioElement.play().then(() => {
                            isAudioPlaying = true;
                             console.log("Audio resumed successfully via onplay.");
                        }).catch(e => console.error("Error resuming audio via onplay:", e));
                    }
                }
            }
            
            function syncAudioPause() {
                 if (scenarioAudioElement.currentSrc && !scenarioAudioElement.paused && currentPlayerElement && currentPlayerElement.paused) {
                    console.log("Video pause detected, pausing audio.");
                    scenarioAudioElement.pause();
                    isAudioPlaying = false;
                }
            }

            function syncAudioSeek() {
                if (scenarioAudioElement.currentSrc && hasAudioStarted && currentPlayerElement) { // Only sync if audio has started
                    console.log("Video seek detected, syncing audio currentTime.");
                    scenarioAudioElement.currentTime = currentPlayerElement.currentTime;
                }
            }

            [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.onplay = () => { if (player === currentPlayerElement) syncAudioPlay(); };
                player.onpause = () => { if (player === currentPlayerElement) syncAudioPause(); };
                player.onseeked = () => { if (player === currentPlayerElement) syncAudioSeek(); };
            });

            // Handle audio ending - it should not loop and should stop video playback
            scenarioAudioElement.onended = () => {
                console.log("Audio track has ended.");
                isAudioPlaying = false;
                // hasAudioStarted remains true, audio does not restart.
                
                // Pause the current video when audio ends but keep it visible
                if (currentPlayerElement && !currentPlayerElement.paused) {
                    currentPlayerElement.pause();
                }
            };
            // --- END NEW FUNCTIONS AND EVENT LISTENERS ---

            // Render developer logs
            function renderDeveloperLogs(logs, turnNumber) {
                // Create a container for the logs if it doesn't exist
                const logsContainerId = `logs-turn-${turnNumber}`;
                let logsContainer = document.getElementById(logsContainerId);

                if (!logsContainer) {
                    // Create a new panel for this turn's logs
                    const panel = document.createElement("div");
                    panel.className = "developer-panel";
                    panel.style.display = developerMode ? "block" : "none";

                    // Create the header
                    const header = document.createElement("div");
                    header.className = "developer-header";
                    header.innerHTML = `
                    <h4>LLM Interactions - Turn ${turnNumber}</h4>
                    <span class="expand-arrow"></span>
                `;

                    // Create the logs container
                    logsContainer = document.createElement("div");
                    logsContainer.className = "logs-container";
                    logsContainer.id = logsContainerId;

                    // Add click handler to toggle expansion
                    header.addEventListener("click", () => {
                        header.classList.toggle("expanded");
                        logsContainer.style.display = header.classList.contains(
                            "expanded",
                        )
                            ? "block"
                            : "none";
                    });

                    // Assemble the panel
                    panel.appendChild(header);
                    panel.appendChild(logsContainer);

                    // Add to the DOM before the response form
                    developerLogsElement.appendChild(panel);
                } else {
                    // Clear existing logs
                    logsContainer.innerHTML = "";
                }

                // Add each log entry
                logs.forEach((log) => {
                    const logEntry = document.createElement("div");
                    logEntry.className = "log-entry";

                    // Create operation header with timestamp and response time
                    const timestamp = new Date(
                        log.timestamp,
                    ).toLocaleTimeString();
                    const responseTime = log.response_time_seconds
                        ? `<span class="response-time">${log.response_time_seconds.toFixed(2)}s</span>`
                        : "";

                    logEntry.innerHTML = `
                    <h5>
                        <span class="badge">${log.operation_name}</span>
                        <small>${timestamp}</small>
                        <small>${log.model_name}</small>
                        ${responseTime}
                    </h5>
                `;

                    // Add prompt
                    const promptPre = document.createElement("pre");
                    promptPre.className = "prompt";
                    promptPre.textContent = log.prompt;

                    // Add completion
                    const completionPre = document.createElement("pre");
                    completionPre.className = "completion";
                    completionPre.textContent = log.completion;

                    // Add parameters
                    const paramsPre = document.createElement("pre");
                    paramsPre.className = "params";
                    paramsPre.textContent = JSON.stringify(
                        log.parameters,
                        null,
                        2,
                    );

                    // Assemble the log entry
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Prompt:";
                    logEntry.appendChild(promptPre);
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Completion:";
                    logEntry.appendChild(completionPre);
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Parameters:";
                    logEntry.appendChild(paramsPre);

                    // Add to the container
                    logsContainer.appendChild(logEntry);
                });
            }

            // Show error message
            function showError(message) {
                errorElement.textContent = message;
                errorElement.style.display = "block";

                // Log additional details in console when in developer mode
                if (developerMode) {
                    console.warn("Developer mode error details:", message);

                    // Add more detailed error to UI in developer mode
                    const errorDetailsElement = document.createElement("pre");
                    errorDetailsElement.className = "error-details";
                    errorDetailsElement.textContent = JSON.stringify(
                        {
                            timestamp: new Date().toISOString(),
                            message: message,
                            simulation_id: simulationId,
                            turn: currentSimulation
                                ? currentSimulation.current_turn_number
                                : "unknown",
                        },
                        null,
                        2,
                    );

                    // Only append if there isn't already an error-details element
                    if (!document.querySelector(".error-details")) {
                        errorElement.appendChild(errorDetailsElement);
                    }
                }

                // Auto-hide error after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = "none";
                    // Clear any error details
                    const errorDetails =
                        errorElement.querySelector(".error-details");
                    if (errorDetails) {
                        errorDetails.remove();
                    }
                }, 10000);
            }

            // Functions to handle generation progress indicators
            function resetProgressIndicators() {
                console.log("Resetting progress indicators");
                // Reset scenario progress
                document.getElementById("scenario-progress-icon").textContent = "...";
                document.getElementById("scenario-progress-icon").classList.remove("complete");
                document.getElementById("scenario-progress-icon").classList.add("pending");
                document.getElementById("scenario-progress-status").textContent = "Pending";
                document.getElementById("scenario-progress-status").classList.remove("complete");
                
                // Reset videos progress
                document.getElementById("videos-progress-icon").textContent = "...";
                document.getElementById("videos-progress-icon").classList.remove("complete");
                document.getElementById("videos-progress-icon").classList.add("pending");
                document.getElementById("videos-progress-status").textContent = "Pending";
                document.getElementById("videos-progress-status").classList.remove("complete");
                
                // Reset audio progress
                document.getElementById("audio-progress-icon").textContent = "...";
                document.getElementById("audio-progress-icon").classList.remove("complete");
                document.getElementById("audio-progress-icon").classList.add("pending");
                document.getElementById("audio-progress-status").textContent = "Pending";
                document.getElementById("audio-progress-status").classList.remove("complete");
            }
            
            function markProgressComplete(type) {
                console.log(`Marking progress complete for: ${type}`);
                const icon = document.getElementById(`${type}-progress-icon`);
                const status = document.getElementById(`${type}-progress-status`);
                
                if (icon && status) {
                    icon.textContent = "";
                    icon.classList.remove("pending");
                    icon.classList.add("complete");
                    status.textContent = "Complete";
                    status.classList.add("complete");
                    console.log(`Progress updated for ${type}: icon=${icon.textContent}, status=${status.textContent}`);
                } else {
                    console.error(`Could not find elements for ${type} progress indicator`);
                }
            }

            // Initialize the UI on page load
            initUI();
            console.log("SCRIPT EXECUTION TEST AT BOTTOM");
        </script>
    </body>
</html>
