<!doctype html>
<html lang="en" data-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Save the World?</title>
        <style>
            :root {
                /* Dark mode variables */
                --bg-color: #121212;
                --container-bg: #1e1e1e;
                --text-color: #e0e0e0;
                --heading-color: #ffffff;
                --accent-color: #64b5f6;
                --secondary-accent: #81c784;
                --error-color: #f44336;
                --border-color: #424242;
                --scenario-bg: #2d2d2d;
                --scenario-border: #64b5f6;
                --conclusion-bg: #263238;
                --conclusion-border: #2196f3;
                --button-bg: #4caf50;
                --button-hover: #45a049;
                --button-disabled: #2e2e2e;
                --history-bg: #333333;
                --form-bg: #2d2d2d;
                --code-bg: #1a1a1a;
                --log-header-bg: #333333;
                --toggle-bg: #555555;
                --toggle-active: #4caf50;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                max-width: 1000px;
                margin: 0 auto;
                padding: 20px;
                background-color: var(--bg-color);
                color: var(--text-color);
            }

            .container {
                background-color: var(--container-bg);
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            h1,
            h2,
            h3,
            h4 {
                color: var(--heading-color);
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
            }

            .header-container {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .header-container h1 {
                margin: 0;
            }

            .controls {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .switch {
                position: relative;
                display: inline-block;
                width: 60px;
                height: 30px;
            }

            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: var(--toggle-bg);
                transition: 0.4s;
                border-radius: 30px;
            }

            .slider:before {
                position: absolute;
                content: "";
                height: 22px;
                width: 22px;
                left: 4px;
                bottom: 4px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }

            input:checked + .slider {
                background-color: var(--toggle-active);
            }

            input:checked + .slider:before {
                transform: translateX(30px);
            }

            .toggle-label {
                font-size: 14px;
                font-weight: bold;
            }

            .scenario {
                margin-bottom: 20px;
                padding: 15px;
                background-color: var(--scenario-bg);
                border-radius: 5px;
                border-left: 5px solid var(--scenario-border);
            }

            .conclusion-scenario {
                margin-bottom: 20px;
                padding: 20px;
                background-color: var(--conclusion-bg);
                border-radius: 5px;
                border-left: 5px solid var(--conclusion-border);
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            }

            .conclusion-scenario h3 {
                color: var(--accent-color);
                margin-top: 0;
                text-align: center;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .grade-display {
                margin: 20px 0;
                padding: 15px;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                border-left: 5px solid var(--secondary-accent);
                text-align: center;
            }

            .grade-value {
                font-size: 1.5em;
                font-weight: bold;
                color: var(--secondary-accent);
            }

            .grade-explanation {
                font-style: italic;
                color: var(--text-color);
                margin-top: 10px;
            }

            .rationale-text {
                font-style: italic;
                color: var(--secondary-accent);
                margin: 15px 0;
                padding-left: 15px;
                border-left: 3px solid var(--accent-color);
            }

            .turn-counter {
                text-align: center;
                font-weight: bold;
                color: var(--accent-color);
                margin-bottom: 20px;
                font-size: 1.2em;
            }

            .media-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin: 20px 0;
                background-color: var(--scenario-bg);
                padding: 15px;
                border-radius: 5px;
            }

            video {
                max-width: 100%;
                border-radius: 5px;
                margin-bottom: 10px;
                background-color: #000;
            }

            audio {
                width: 100%;
                margin-bottom: 20px;
                background-color: var(--container-bg);
                border-radius: 20px;
            }

            .response-form {
                margin-top: 20px;
                background-color: var(--form-bg);
                padding: 15px;
                border-radius: 5px;
            }

            textarea {
                width: 100%;
                padding: 10px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                resize: vertical;
                min-height: 100px;
                background-color: var(--container-bg);
                color: var(--text-color);
            }

            button {
                display: inline-block;
                background-color: var(--button-bg);
                color: white;
                border: none;
                padding: 10px 15px;
                margin-top: 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                transition: background-color 0.2s;
            }

            button:hover {
                background-color: var(--button-hover);
            }

            button:disabled {
                background-color: var(--button-disabled);
                color: #777;
                cursor: not-allowed;
            }

            .loading {
                text-align: center;
                margin: 20px 0;
                color: var(--accent-color);
                padding: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                border-radius: 8px;
                max-width: 400px;
                margin: 20px auto;
            }

            .generation-progress {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-top: 15px;
                text-align: left;
                padding: 10px;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 5px;
            }

            .progress-item {
                display: flex;
                align-items: center;
                color: #999;
                font-size: 14px;
            }

            .progress-icon {
                display: inline-flex;
                justify-content: center;
                align-items: center;
                width: 24px;
                height: 24px;
                border-radius: 12px;
                margin-right: 10px;
                font-weight: bold;
                background-color: #333;
            }

            .progress-icon.complete {
                background-color: #004400;
                color: #00ff00;
            }

            .progress-icon.pending {
                color: #999;
            }

            .progress-label {
                flex-grow: 1;
            }

            .progress-status {
                font-size: 12px;
            }

            .progress-status.complete {
                color: #00ff00;
            }

            .history {
                margin-top: 30px;
                padding-top: 20px;
                border-top: 1px solid var(--border-color);
            }

            .history-item {
                margin-bottom: 15px;
                padding: 10px;
                background-color: var(--history-bg);
                border-radius: 4px;
            }

            .history-item h3 {
                margin-top: 0;
                color: var(--heading-color);
            }

            .history-turn {
                margin-bottom: 20px;
                padding: 15px;
                background-color: var(--history-bg);
                border-radius: 5px;
                border-left: 3px solid var(--accent-color);
            }

            .history-scenario {
                margin-bottom: 10px;
                padding: 10px;
                background-color: rgba(255, 255, 255, 0.05);
                border-radius: 4px;
            }

            .history-response {
                margin-top: 10px;
                padding: 0 10px;
            }

            .history-response h4 {
                color: var(--secondary-accent);
                margin-bottom: 5px;
            }

            .error {
                color: var(--error-color);
                background-color: rgba(244, 67, 54, 0.1);
                padding: 10px;
                border-radius: 4px;
                margin-bottom: 15px;
                display: none;
            }

            /* Developer Mode Styles */
            .developer-panel {
                margin-top: 15px;
                border: 1px solid var(--border-color);
                border-radius: 5px;
                overflow: hidden;
                display: none;
            }

            .developer-header {
                background-color: var(--log-header-bg);
                padding: 10px 15px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .developer-header h4 {
                margin: 0;
                font-size: 14px;
                color: var(--accent-color);
            }

            .logs-container {
                padding: 0 15px;
                max-height: 500px;
                overflow-y: auto;
                background-color: var(--code-bg);
                display: none;
            }

            .log-entry {
                margin: 15px 0;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 15px;
            }

            .log-entry h5 {
                color: var(--accent-color);
                margin: 5px 0;
            }

            .log-entry pre {
                background-color: var(--container-bg);
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
                color: var(--text-color);
                font-size: 13px;
                margin: 5px 0;
            }

            .log-entry .prompt {
                border-left: 3px solid var(--secondary-accent);
            }

            .log-entry .completion {
                border-left: 3px solid var(--accent-color);
            }

            .log-entry .params {
                border-left: 3px solid var(--scenario-border);
                font-size: 12px;
            }

            .expand-arrow {
                transition: transform 0.3s;
            }

            .expanded .expand-arrow {
                transform: rotate(180deg);
            }

            .expanded + .logs-container {
                display: block;
            }

            .badge {
                display: inline-block;
                padding: 4px 8px;
                border-radius: 30px;
                font-size: 12px;
                font-weight: bold;
                background-color: var(--scenario-border);
                color: var(--container-bg);
            }

            .response-time {
                font-size: 0.9em;
                font-weight: bold;
                color: var(--secondary-accent);
                background-color: rgba(0, 0, 0, 0.2);
                padding: 2px 6px;
                border-radius: 4px;
                margin-left: 10px;
                display: inline-block;
            }

            .error-message {
                background-color: var(--error-color);
                color: white;
                padding: 10px;
                border-radius: 4px;
                margin: 10px 0;
                text-align: center;
                display: none;
            }

            .error-details {
                font-size: 10px;
                margin-top: 10px;
                padding: 8px;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
                overflow: auto;
                max-height: 150px;
                white-space: pre-wrap;
                font-family: monospace;
                text-align: left;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header-container">
                <h1>Save the World?</h1>
                <div class="controls">
                    <span class="toggle-label">Developer Mode</span>
                    <label class="switch">
                        <input type="checkbox" id="developer-mode-toggle" />
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div id="error" class="error"></div>

            <div id="loading" class="loading" style="display: none">
                <p>Loading simulation...</p>
                <div class="generation-progress" style="margin-top: 15px">
                    <div class="progress-item">
                        <span
                            class="progress-icon pending"
                            id="scenario-progress-icon"
                            >...</span
                        >
                        <span class="progress-label">Scenario Generated</span>
                        <span
                            class="progress-status"
                            id="scenario-progress-status"
                            >Pending</span
                        >
                    </div>
                    <div class="progress-item">
                        <span
                            class="progress-icon pending"
                            id="videos-progress-icon"
                            >...</span
                        >
                        <span class="progress-label">Videos Generated</span>
                        <span
                            class="progress-status"
                            id="videos-progress-status"
                            >Pending</span
                        >
                    </div>
                    <div class="progress-item">
                        <span
                            class="progress-icon pending"
                            id="audio-progress-icon"
                            >...</span
                        >
                        <span class="progress-label">Audio Generated</span>
                        <span class="progress-status" id="audio-progress-status"
                            >Pending</span
                        >
                    </div>
                </div>
            </div>

            <div id="simulation-container" style="display: none">
                <div class="turn-counter">
                    Turn <span id="current-turn">1</span> of
                    <span id="max-turns">5</span>
                </div>

                <div class="scenario" id="current-scenario">
                    <p>Click "Generate Scenario" to begin.</p>
                </div>

                <div class="media-container">
                    <video id="scenario-video" controls style="display: none">
                        <source src="" type="video/mp4" />
                        Your browser does not support the video tag.
                    </video>
                    <video
                        id="scenario-video-buffer"
                        controls
                        style="display: none"
                    >
                        <source src="" type="video/mp4" />
                        Your browser does not support the video tag.
                    </video>

                    <audio id="scenario-audio" style="display: none">
                        <source src="" type="audio/mpeg" />
                        Your browser does not support the audio tag.
                    </audio>
                </div>

                <div id="developer-logs"></div>

                <div class="response-form">
                    <textarea
                        id="user-response"
                        placeholder="How do you respond to this situation?"
                    ></textarea>
                    <div style="display: flex; justify-content: space-between">
                        <button id="start-btn">Generate Scenario</button>
                        <button id="submit-btn" disabled>
                            Submit Response
                        </button>
                    </div>
                </div>
            </div>

            <div id="history" class="history" style="display: none">
                <h2>Simulation History</h2>
                <div id="history-content"></div>
            </div>
        </div>

        <script>
            console.log("SCRIPT EXECUTION TEST AT TOP");
            // Global variables
            let simulationId = null;
            let wsConnection = null;
            let currentSimulation = null;
            let developerMode = false;

            // Variables for managing sequential video playback
            let currentVideoPlaylist = [];
            let currentVideoPlaybackIndex = 0;
            let actualUniqueUrlCount = 0;
            let hasAudioStarted = false; // Tracks if audio has been initiated by the user
            let isAudioPlaying = false; // Tracks if audio is currently playing

            // Video player elements for preloading
            const scenarioVideoElement =
                document.getElementById("scenario-video");
            const scenarioVideoBufferElement = document.getElementById(
                "scenario-video-buffer",
            );
            let currentPlayerElement = scenarioVideoElement;
            let bufferPlayerElement = scenarioVideoBufferElement;
            let isBufferVideoReady = false; // Track if buffer video is fully loaded and ready
            let isSeeking = false; // Flag to prevent sync issues during seeking

            // DOM elements
            const errorElement = document.getElementById("error");
            const loadingElement = document.getElementById("loading");
            const simulationContainer = document.getElementById(
                "simulation-container",
            );
            const currentScenarioElement =
                document.getElementById("current-scenario");
            const currentTurnElement = document.getElementById("current-turn");
            const userResponseElement =
                document.getElementById("user-response");
            const startButton = document.getElementById("start-btn");
            const submitButton = document.getElementById("submit-btn");
            const historyElement = document.getElementById("history");
            const historyContentElement =
                document.getElementById("history-content");
            const scenarioAudioElement =
                document.getElementById("scenario-audio");
            const developerLogsElement =
                document.getElementById("developer-logs");
            const developerModeToggle = document.getElementById(
                "developer-mode-toggle",
            );

            // Event listeners
            startButton.addEventListener("click", startSimulation);
            submitButton.addEventListener("click", submitResponse);
            developerModeToggle.addEventListener("click", toggleDeveloperMode);

            // Add error listeners for media elements
            scenarioVideoElement.addEventListener("error", (e) =>
                handleMediaError(e, "scenarioVideoElement"),
            );
            scenarioVideoBufferElement.addEventListener("error", (e) =>
                handleMediaError(e, "scenarioVideoBufferElement"),
            );
            scenarioAudioElement.addEventListener("error", (e) =>
                handleMediaError(e, "scenarioAudioElement"),
            );

            // Initialize custom properties
            scenarioVideoElement.isSwapping = false;
            scenarioVideoBufferElement.isSwapping = false;

            // Initialize the UI
            function initUI() {
                simulationContainer.style.display = "block";
                startButton.disabled = false;
                submitButton.disabled = true;
                userResponseElement.value = "";

                // Ensure buffer is hidden and current player is correctly displayed (initially hidden until content)
                currentPlayerElement.style.display = "none";
                bufferPlayerElement.style.display = "none";

                // Initialize swapping flags
                scenarioVideoElement.isSwapping = false;
                scenarioVideoBufferElement.isSwapping = false;

                // Check if there's a saved simulation in localStorage
                const savedSimulationId = localStorage.getItem("simulationId");
                if (savedSimulationId) {
                    loadSimulation(savedSimulationId);
                }
            }

            // Handle media loading errors
            function handleMediaError(event, elementName) {
                const error = event.target.error;
                let errorMessage = `Media Error on ${elementName}: `;
                if (error) {
                    switch (error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMessage +=
                                "Playback aborted by user or script.";
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMessage +=
                                "Network error caused download to fail.";
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMessage += "Media decoding error.";
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage +=
                                "Media source format not supported.";
                            break;
                        default:
                            errorMessage += "An unknown error occurred.";
                    }
                    errorMessage += ` (Code: ${error.code})`;
                    if (event.target.currentSrc) {
                        errorMessage += `\nSource: ${event.target.currentSrc}`;
                    }
                } else {
                    errorMessage +=
                        "An unknown error occurred (no error object).";
                }
                console.error(errorMessage, event);
                // Optionally show a user-facing error, but be mindful of cascading errors
                // showError(`Media playback error on ${elementName}. Please check console for details.`);

                // Attempt recovery? Maybe try reloading the source or skipping? For now, just log.
                // If it's the current player, maybe try swapping or stopping.
                if (player === currentPlayerElement) {
                    // Stop playback if current player fails critically
                    stopPlaybackAndAudio();
                }
            }

            // Toggle developer mode
            async function toggleDeveloperMode() {
                developerMode = developerModeToggle.checked;

                if (simulationId) {
                    try {
                        const response = await fetch(
                            `/api/simulations/${simulationId}/developer-mode`,
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    enabled: developerMode,
                                }),
                            },
                        );

                        if (!response.ok) {
                            throw new Error(
                                `Error toggling developer mode: ${response.statusText}`,
                            );
                        }

                        // Update UI based on developer mode state
                        updateDeveloperModeUI();

                        // No need to update simulation here as WebSocket will handle it
                    } catch (error) {
                        showError(
                            `Failed to toggle developer mode: ${error.message}`,
                        );
                    }
                } else {
                    // Just update the UI if no simulation is active yet
                    updateDeveloperModeUI();
                }
            }

            // Update UI based on developer mode state
            function updateDeveloperModeUI() {
                // Show/hide developer logs based on mode
                const logEntries =
                    document.querySelectorAll(".developer-panel");
                logEntries.forEach((entry) => {
                    entry.style.display = developerMode ? "block" : "none";
                });
            }

            // Set up WebSocket connection for real-time updates
            function setupWebSocket() {
                // Close existing connection if any
                if (wsConnection) {
                    wsConnection.close();
                }

                // Create new WebSocket connection
                const protocol =
                    window.location.protocol === "https:" ? "wss:" : "ws:";
                const wsUrl = `${protocol}//${window.location.host}/api/ws/simulations/${simulationId}`;
                wsConnection = new WebSocket(wsUrl);

                // Set up event handlers
                wsConnection.onopen = () => {
                    console.log("WebSocket connection established");
                };

                wsConnection.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log("WebSocket message received:", message);

                    if (
                        message.type === "simulation_state" ||
                        message.type === "simulation_updated"
                    ) {
                        updateSimulationUI(message.simulation);
                        // Once the main simulation state is updated, we can hide the loading spinner.
                        // Ensure this happens after any potential progress checkmarks have appeared.
                        setTimeout(() => {
                            loadingElement.style.display = "none";
                        }, 1000); // Add a small delay to allow users to see final checkmarks
                    } else if (message.type === "progress_update") {
                        console.log(
                            `Progress update received for step: ${message.step}`,
                        );
                        if (message.step === "scenario_generated") {
                            markProgressComplete("scenario");
                        } else if (message.step === "videos_generated") {
                            markProgressComplete("videos");
                        } else if (message.step === "audio_generated") {
                            markProgressComplete("audio");
                        }
                        // Keep loading visible until simulation_state or simulation_updated is received
                    }
                };

                wsConnection.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    // Consider hiding loading on critical WebSocket errors if simulation cannot proceed
                    // loadingElement.style.display = "none";
                };

                wsConnection.onclose = () => {
                    console.log("WebSocket connection closed");
                    // Try to reconnect after a delay
                    setTimeout(() => {
                        if (simulationId) {
                            setupWebSocket();
                        }
                    }, 3000);
                };
            }

            // Start a new simulation
            async function startSimulation() {
                // Clear any existing content
                currentScenarioElement.innerHTML =
                    "<p>Generating scenario...</p>";
                historyElement.style.display = "none";
                historyContentElement.innerHTML = "";
                developerLogsElement.innerHTML = "";

                // Stop any existing playback
                stopPlaybackAndAudio();

                // Disable the start button and show loading state
                startButton.disabled = true;
                loadingElement.style.display = "block";

                // Reset progress indicators
                resetProgressIndicators();

                // Reset audio flags
                hasAudioStarted = false;
                isAudioPlaying = false;
                currentVideoPlaybackIndex = 0; // Reset for the new simulation

                try {
                    // Create a new simulation
                    const response = await fetch("/api/simulations", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            initial_prompt: "",
                            developer_mode: developerMode,
                        }),
                    });

                    if (!response.ok) {
                        throw new Error(
                            `Error creating simulation: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();
                    simulationId = simulation.simulation_id;

                    // Scenario progress will be marked by WebSocket message "scenario_generated"

                    // Save simulation ID to localStorage
                    localStorage.setItem("simulationId", simulationId);

                    // Set up WebSocket connection - this will handle subsequent progress updates
                    setupWebSocket();

                    // UI will be updated by "simulation_state" or "simulation_updated" message
                    // Loading spinner will be hidden by WebSocket message handler too.

                    // Initial state updates (non-progress related) for the new simulation
                    hasAudioStarted = false;
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0;
                    actualUniqueUrlCount = 0;
                    currentPlayerElement = scenarioVideoElement;
                    bufferPlayerElement = scenarioVideoBufferElement;
                    currentPlayerElement.isSwapping = false; // Reset flag
                    bufferPlayerElement.isSwapping = false; // Reset flag
                    console.log(
                        "[UI Update] Reset currentPlayerElement to scenarioVideoElement for new turn media.",
                    );
                } catch (error) {
                    showError(`Failed to start simulation: ${error.message}`);
                    startButton.disabled = false;
                    loadingElement.style.display = "none"; // Hide loading on error
                }
            }

            // Load an existing simulation
            async function loadSimulation(id) {
                // Show loading state
                loadingElement.style.display = "block";

                // Stop any existing playback before loading
                stopPlaybackAndAudio();

                // Reset progress indicators
                resetProgressIndicators();

                try {
                    // Get the simulation
                    const response = await fetch(`/api/simulations/${id}`);

                    if (!response.ok) {
                        // If not found, clear localStorage and reset UI
                        if (response.status === 404) {
                            localStorage.removeItem("simulationId");
                            loadingElement.style.display = "none";
                            return;
                        }
                        throw new Error(
                            `Error loading simulation: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();
                    simulationId = simulation.simulation_id;

                    // Set developer mode toggle based on simulation state
                    developerMode = simulation.developer_mode;
                    developerModeToggle.checked = developerMode;

                    // Set up WebSocket connection - this will handle progress and state updates
                    setupWebSocket();

                    // Scenario progress will be marked by WebSocket message "scenario_generated"
                    // Video/Audio progress will also be marked by WebSocket messages.

                    // Initial state updates (non-progress related) for the loaded simulation
                    hasAudioStarted = false;
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0;
                    actualUniqueUrlCount = 0;
                    currentPlayerElement = scenarioVideoElement;
                    bufferPlayerElement = scenarioVideoBufferElement;
                    currentPlayerElement.isSwapping = false; // Reset flag
                    bufferPlayerElement.isSwapping = false; // Reset flag
                    console.log(
                        "[UI Update] Reset currentPlayerElement to scenarioVideoElement for new turn media.",
                    );

                    // The updateSimulationUI and hiding of loadingElement will be handled by WebSocket messages.
                } catch (error) {
                    showError(`Failed to load simulation: ${error.message}`);
                    localStorage.removeItem("simulationId");
                    loadingElement.style.display = "none"; // Hide loading on error
                }
            }

            // Submit user response to the current scenario
            async function submitResponse() {
                // Get user response
                const responseText = userResponseElement.value.trim();
                if (!responseText) {
                    showError("Please enter a response before submitting.");
                    return;
                }

                // Stop playback before submitting
                stopPlaybackAndAudio();

                // Disable the submit button and show loading state
                submitButton.disabled = true;
                loadingElement.style.display = "block";

                try {
                    // Submit the response to the API
                    const response = await fetch(
                        `/api/simulations/${simulationId}/respond`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                response_text: responseText,
                            }),
                        },
                    );

                    if (!response.ok) {
                        throw new Error(
                            `Error submitting response: ${response.statusText}`,
                        );
                    }

                    const simulation = await response.json();

                    // Update the UI with the updated simulation
                    updateSimulationUI(simulation);

                    // Clear the response input
                    userResponseElement.value = "";

                    // Hide loading state
                    loadingElement.style.display = "none";
                } catch (error) {
                    console.error("Response submission error:", error);
                    showError(`Failed to submit response: ${error.message}`);

                    // Try to recover the UI state
                    try {
                        // Get the current simulation state to recover
                        const getResponse = await fetch(
                            `/api/simulations/${simulationId}`,
                        );
                        if (getResponse.ok) {
                            const updatedSimulation = await getResponse.json();
                            updateSimulationUI(updatedSimulation);
                            showError(
                                "Your response was saved, but there was an error generating the next scenario. Please continue.",
                            );
                        }
                    } catch (recoveryError) {
                        console.error("Recovery error:", recoveryError);
                    }

                    submitButton.disabled = false;
                    loadingElement.style.display = "none";
                }
            }

            // Update UI with simulation data
            function updateSimulationUI(simulation) {
                console.log(
                    "[UI Update] Received simulation data:",
                    JSON.parse(JSON.stringify(simulation)),
                ); // Log incoming simulation object
                // Save the simulation
                currentSimulation = simulation;

                // Update turn counter
                currentTurnElement.textContent = simulation.current_turn_number;
                document.getElementById("max-turns").textContent =
                    simulation.max_turns;

                // Get the current turn
                const currentTurn = simulation.turns.find(
                    (t) => t.turn_number === simulation.current_turn_number,
                );

                // Update scenario display
                if (currentTurn && currentTurn.selected_scenario) {
                    // We no longer mark progress here as it's handled by delayed sequence above

                    // Stop any previous turn's media before updating UI
                    stopPlaybackAndAudio();

                    // Handle final turn differently (conclusion)
                    if (
                        simulation.current_turn_number === simulation.max_turns
                    ) {
                        currentScenarioElement.className =
                            "conclusion-scenario";
                        currentScenarioElement.innerHTML = `
                        <h3>Conclusion</h3>
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        <p class="rationale-text">${currentTurn.selected_scenario.rationale || ""}</p>
                        <div class="grade-display">
                            <h4>Final Grade: <span class="grade-value">${currentTurn.selected_scenario.grade !== undefined ? currentTurn.selected_scenario.grade : "N/A"}/100</span></h4>
                        </div>
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    } else if (simulation.current_turn_number === 1) {
                        // Turn 1: Show situation_description + user_role + user_prompt
                        currentScenarioElement.className = "scenario";
                        currentScenarioElement.innerHTML = `
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        ${
                            currentTurn.selected_scenario.user_role &&
                            currentTurn.selected_scenario.user_prompt
                                ? `<p><strong>${currentTurn.selected_scenario.user_role}</strong> ${currentTurn.selected_scenario.user_prompt}</p>`
                                : currentTurn.selected_scenario.user_role
                                  ? `<p><strong>${currentTurn.selected_scenario.user_role}</strong></p>`
                                  : currentTurn.selected_scenario.user_prompt
                                    ? `<p>${currentTurn.selected_scenario.user_prompt}</p>`
                                    : ""
                        }
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    } else {
                        // Middle turns: Show only situation_description + user_prompt
                        currentScenarioElement.className = "scenario";
                        currentScenarioElement.innerHTML = `
                        <p>${currentTurn.selected_scenario.situation_description}</p>
                        ${
                            currentTurn.selected_scenario.user_prompt
                                ? `<p>${currentTurn.selected_scenario.user_prompt}</p>`
                                : ""
                        }
                        ${developerMode ? `<pre class="debug-data" style="font-size: 10px; margin-top: 20px; padding: 10px; background: #222; border: 1px solid #555;">Scenario Data: ${JSON.stringify(currentTurn.selected_scenario, null, 2)}</pre>` : ""}
                    `;
                    }

                    // Update media
                    console.log(
                        "[UI Update] Current turn object:",
                        JSON.parse(JSON.stringify(currentTurn)),
                    );
                    console.log(
                        "[UI Update] Checking currentTurn.video_urls:",
                        currentTurn.video_urls,
                    );

                    // Reset audio state for new turn media
                    hasAudioStarted = false;
                    isAudioPlaying = false;
                    currentVideoPlaybackIndex = 0; // Reset for new playlist for this turn
                    actualUniqueUrlCount = 0;

                    if (
                        currentTurn.video_urls &&
                        Array.isArray(currentTurn.video_urls) &&
                        currentTurn.video_urls.length > 0
                    ) {
                        // Progress marking is now handled in the delayed sequence above

                        console.log(
                            "[UI Update] video_urls is a non-empty array. Processing...",
                        );
                        const processedUrlsFromTurn = [];
                        currentTurn.video_urls.forEach((url) => {
                            if (url && typeof url === "string") {
                                processedUrlsFromTurn.push(url);
                            }
                        });

                        // Ensure we only use unique URLs for the two-pass playlist
                        const actualUniqueUrls = [
                            ...new Set(processedUrlsFromTurn),
                        ];
                        console.log(
                            "[UI Update] Actual unique URLs for playlist:",
                            actualUniqueUrls,
                        );

                        // Create the playlist: just use the unique sequence without repeating
                        currentVideoPlaylist = [...actualUniqueUrls];
                        actualUniqueUrlCount = actualUniqueUrls.length; // Store count of unique videos

                        console.log(
                            "[UI Update] Generated video playlist (Corrected Order):",
                            currentVideoPlaylist,
                        );
                        currentVideoPlaybackIndex = 0; // Reset index

                        if (currentVideoPlaylist.length > 0) {
                            console.log(
                                "[UI Update] Playlist has videos. Initializing playback setup.",
                            );
                            // Ensure players are reset and hidden initially
                            currentPlayerElement.style.display = "none";
                            bufferPlayerElement.style.display = "none";
                            currentPlayerElement.querySelector("source").src =
                                ""; // Clear source
                            bufferPlayerElement.querySelector("source").src =
                                ""; // Clear source
                            currentPlayerElement.load(); // Reset state
                            bufferPlayerElement.load(); // Reset state
                            isBufferVideoReady = false; // Reset buffer flag

                            // Load the first video into the primary player, but don't play yet
                            console.log(
                                `[UI Update] Preloading first video (${currentVideoPlaylist[0]}) into ${currentPlayerElement.id}`,
                            );
                            loadVideoIntoPlayer(
                                currentPlayerElement,
                                currentVideoPlaylist[0],
                            );
                            currentPlayerElement.style.display = "block"; // Make it visible for user interaction

                            // Preload the second video (if exists) into the buffer player
                            if (currentVideoPlaylist.length > 1) {
                                console.log(
                                    `[UI Update] Preloading second video (${currentVideoPlaylist[1]}) into ${bufferPlayerElement.id}`,
                                );
                                loadVideoIntoPlayer(
                                    bufferPlayerElement,
                                    currentVideoPlaylist[1],
                                );
                            }
                        } else {
                            console.log(
                                "[UI Update] Playlist is empty after processing. Hiding players.",
                            );
                            currentPlayerElement.style.display = "none";
                            bufferPlayerElement.style.display = "none";
                        }
                    } else {
                        // Progress marking is now handled in the delayed sequence above

                        console.log(
                            "[UI Update] video_urls is NOT a valid non-empty array. Hiding video player.",
                        );
                        console.log(
                            "[UI Update] Value of currentTurn.video_urls:",
                            currentTurn.video_urls,
                        );
                        console.log(
                            "[UI Update] Is Array?",
                            Array.isArray(currentTurn.video_urls),
                        );
                        if (currentTurn.video_urls)
                            console.log(
                                "[UI Update] Length:",
                                currentTurn.video_urls.length,
                            );
                        scenarioVideoElement.style.display = "none"; // No valid videos in the list
                        currentVideoPlaylist = []; // Clear playlist if no videos are provided
                        currentVideoPlaybackIndex = 0;
                        // Also hide buffer player if no videos
                        scenarioVideoBufferElement.style.display = "none";
                    }

                    if (currentTurn.audio_url) {
                        // Progress marking is now handled in the delayed sequence above

                        console.log(
                            "[UI Update] Received audio_url:",
                            currentTurn.audio_url,
                        );
                        scenarioAudioElement.querySelector("source").src =
                            currentTurn.audio_url;
                        scenarioAudioElement.load();
                        // scenarioAudioElement.style.display = "block"; // No longer needed, audio is invisible
                        // Reset audio playback state
                        hasAudioStarted = false;
                        isAudioPlaying = false;
                    } else {
                        // Progress marking is now handled in the delayed sequence above

                        console.log(
                            "[UI Update] No audio_url received for this turn.",
                        );
                        scenarioAudioElement.querySelector("source").src = "";
                        scenarioAudioElement.load();
                        // scenarioAudioElement.style.display = "none"; // Already default or handled by CSS if we add it
                    }

                    // Update buttons
                    submitButton.disabled =
                        Boolean(currentTurn.user_response) ||
                        simulation.is_complete;
                    startButton.textContent = simulation.is_complete
                        ? "Start New Simulation"
                        : "Restart Simulation";
                    startButton.disabled = false;

                    // Update developer logs if developer mode is enabled
                    if (
                        currentTurn.llm_logs &&
                        currentTurn.llm_logs.length > 0
                    ) {
                        renderDeveloperLogs(
                            currentTurn.llm_logs,
                            currentTurn.turn_number,
                        );
                    }
                } else {
                    // No scenario selected yet
                    currentScenarioElement.className = "scenario";
                    currentScenarioElement.innerHTML =
                        "<p>Waiting for scenario generation...</p>";
                    submitButton.disabled = true;
                }

                // Update history
                if (simulation.turns.length > 0) {
                    historyElement.style.display = "block";
                    historyContentElement.innerHTML = "";

                    // Sort turns by turn number
                    const sortedTurns = [...simulation.turns].sort(
                        (a, b) => a.turn_number - b.turn_number,
                    );

                    // Skip the current turn
                    const historyTurns = sortedTurns.filter(
                        (t) => t.turn_number < simulation.current_turn_number,
                    );

                    if (historyTurns.length > 0) {
                        historyTurns.forEach((turn) => {
                            if (turn.selected_scenario && turn.user_response) {
                                const turnElement =
                                    document.createElement("div");
                                turnElement.className = "history-turn";
                                turnElement.innerHTML = `
                                <h3>Turn ${turn.turn_number}</h3>
                                <div class="history-scenario">
                                    <p>${turn.selected_scenario.situation_description}</p>
                                    ${
                                        turn.selected_scenario.user_role &&
                                        turn.selected_scenario.user_prompt
                                            ? `<p><strong>${turn.selected_scenario.user_role}</strong> ${turn.selected_scenario.user_prompt}</p>`
                                            : turn.selected_scenario.user_role
                                              ? `<p><strong>${turn.selected_scenario.user_role}</strong></p>`
                                              : turn.selected_scenario
                                                      .user_prompt
                                                ? `<p>${turn.selected_scenario.user_prompt}</p>`
                                                : ""
                                    }
                                </div>
                                <div class="history-response">
                                    <h4>Your Response:</h4>
                                    <p>${turn.user_response ? turn.user_response.response_text : "No response recorded"}</p>
                                </div>
                            `;
                                historyContentElement.appendChild(turnElement);
                            }
                        });
                    } else {
                        historyElement.style.display = "none";
                    }
                } else {
                    historyElement.style.display = "none";
                }

                // Update developer mode UI
                developerModeToggle.checked = simulation.developer_mode;
                developerMode = simulation.developer_mode;
                updateDeveloperModeUI();
            }

            // --- NEW FUNCTION FOR SEQUENTIAL VIDEO PLAYBACK ---
            // This function is replaced by the refined logic below
            /*
            function playNextVideoInSequence() {
                // ... old implementation ...
            }
            */

            function loadVideoIntoPlayer(playerElement, videoUrl) {
                if (!playerElement || !videoUrl) {
                    console.warn(
                        "loadVideoIntoPlayer: Invalid player or URL.",
                        playerElement,
                        videoUrl,
                    );
                    return;
                }

                console.log(
                    `[LoadVideo] Attempting to load ${videoUrl} into ${playerElement.id}`,
                );

                // Reset swapping flag for the player being loaded
                playerElement.isSwapping = false;

                // Remove *all* previous listeners to prevent duplicates or leaks
                // Store current time if needed (though usually we start fresh)
                // const currentTime = playerElement.currentTime;

                // Remove specific listeners if added elsewhere, or use a more robust cleanup
                playerElement.oncanplay = null;
                playerElement.oncanplaythrough = null; // Add this one too
                playerElement.onloadeddata = null; // If using this
                playerElement.onerror = null; // Re-add general error handler later if needed

                // Re-attach the general media error handler
                playerElement.onerror = (e) =>
                    handleMediaError(e, playerElement.id);

                playerElement.querySelector("source").src = videoUrl;
                playerElement.load(); // Important: load the new source

                // Use 'canplaythrough' for the buffer player to ensure it's more fully loaded
                // Use 'canplay' for the current player as we want it to be ready sooner
                if (playerElement === bufferPlayerElement) {
                    playerElement.oncanplaythrough = function () {
                        // Check if this is still the intended buffer video (race condition prevention)
                        if (playerElement.currentSrc.endsWith(videoUrl)) {
                            isBufferVideoReady = true;
                            console.log(
                                `[LoadVideo] Buffer video (${videoUrl}) can play through (readyState: ${playerElement.readyState}).`,
                            );
                        } else {
                            console.warn(
                                `[LoadVideo] Buffer 'canplaythrough' event for wrong video? Expected ${videoUrl}, got ${playerElement.currentSrc}`,
                            );
                        }
                    };
                    // Fallback or additional check with 'canplay' if 'canplaythrough' takes too long? Maybe not needed.
                } else {
                    // currentPlayerElement
                    playerElement.oncanplay = function () {
                        // Check if this is still the intended current video
                        if (playerElement.currentSrc.endsWith(videoUrl)) {
                            console.log(
                                `[LoadVideo] Current video (${videoUrl}) can play (readyState: ${playerElement.readyState}).`,
                            );
                            // If this is a subsequent video in the sequence AND audio is playing, start it
                            if (
                                currentVideoPlaybackIndex > 0 &&
                                hasAudioStarted &&
                                isAudioPlaying &&
                                playerElement.paused
                            ) {
                                console.log(
                                    `[LoadVideo] Auto-playing subsequent video ${playerElement.id} via oncanplay.`,
                                );
                                attemptPlayVideo(playerElement);
                            }
                        } else {
                            console.warn(
                                `[LoadVideo] Current 'canplay' event for wrong video? Expected ${videoUrl}, got ${playerElement.currentSrc}`,
                            );
                        }
                    };
                }

                console.log(
                    `[LoadVideo] ${videoUrl} source set for ${playerElement.id}. Waiting for ready events.`,
                );
            }

            // Removed - logic integrated into event listeners and swap function
            /*
            function startOrContinuePlayback() {
                 // ... old implementation ...
            }
            */

            function handleVideoEndAndSwap() {
                console.log(
                    `[Swap] Video in ${currentPlayerElement.id} ended. Index: ${currentVideoPlaybackIndex}. Buffer ready: ${isBufferVideoReady}`,
                );

                if (currentVideoPlaylist.length <= 1) {
                    console.log(
                        "[Swap] Only one video or empty playlist, stopping.",
                    );
                    // If only one video, just pause it. Audio ending will handle stopping.
                    if (!currentPlayerElement.paused)
                        currentPlayerElement.pause();
                    // If audio should also stop here (e.g., loop requested only if multiple videos)
                    // stopPlaybackAndAudio(); // Uncomment if audio should stop with single video end
                    return;
                }

                // Only proceed if the buffer video is ready
                if (!isBufferVideoReady) {
                    console.log(
                        "[Swap] Buffer video not ready yet, waiting...",
                    );
                    // Re-check shortly. Avoid indefinite loops. Add a counter?
                    // For now, just try again once. If still not ready, playback might stall.
                    setTimeout(() => {
                        if (isBufferVideoReady) {
                            console.log(
                                "[Swap] Buffer video ready after short wait. Performing swap.",
                            );
                            performSwap();
                        } else {
                            console.warn(
                                "[Swap] Buffer video still not ready after wait. Playback may stall.",
                            );
                            // Maybe try loading the buffer again? Or just stop?
                            // For now, we stop to avoid unpredictable behavior.
                            stopPlaybackAndAudio();
                        }
                    }, 100); // Increased wait time slightly
                    return;
                }

                // Buffer is ready, proceed with the swap
                performSwap();
            }

            // Removed - integrated into handleVideoEndAndSwap with a timeout
            /*
            // Separate function to check buffer readiness and perform swap
            function checkBufferAndSwap() {
                // ... old implementation ...
            }
            */

            // Function to perform the actual swap once buffer is ready
            function performSwap() {
                // Increment index and wrap around for loop
                currentVideoPlaybackIndex =
                    (currentVideoPlaybackIndex + 1) %
                    currentVideoPlaylist.length;
                console.log(
                    `[Swap] Swapping players. New index: ${currentVideoPlaybackIndex}`,
                );

                // Swap player roles
                let temp = currentPlayerElement;
                currentPlayerElement = bufferPlayerElement;
                bufferPlayerElement = temp;

                // Update visibility: Make new current player visible, hide the new buffer player
                currentPlayerElement.style.display = "block";
                bufferPlayerElement.style.display = "none";

                // Play the new current player immediately
                // Ensure audio is synced ONLY if audio is supposed to be playing
                console.log(
                    `[Swap] Attempting to play new current player: ${currentPlayerElement.id}. Audio should be playing: ${!scenarioAudioElement.ended}`,
                );
                // We attempt to play regardless of the isAudioPlaying flag here,
                // because the decision to swap was already based on the audio *not* being ended.
                // syncAudioPlay (triggered by onplay) will handle audio state.
                attemptPlayVideo(currentPlayerElement);

                // Start preloading the *next* video into the (now hidden) buffer player
                const nextVideoIndex =
                    (currentVideoPlaybackIndex + 1) %
                    currentVideoPlaylist.length;
                const nextVideoUrl = currentVideoPlaylist[nextVideoIndex];
                console.log(
                    `[Swap] Preloading next video (index ${nextVideoIndex}, URL: ${nextVideoUrl}) into buffer player (${bufferPlayerElement.id})`,
                );
                isBufferVideoReady = false; // Reset buffer readiness flag *before* loading
                loadVideoIntoPlayer(bufferPlayerElement, nextVideoUrl);
            }

            // Removed - timeupdate logic can be complex and might not be necessary with canplaythrough
            /*
            // Add event listener to preload video when it's halfway through playback
            [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.addEventListener("timeupdate", () => {
                     // ... old implementation ...
                });
            });
            */

            // Universal 'ended' event listener for both video players
            [scenarioVideoElement, scenarioVideoBufferElement].forEach(
                (player) => {
                    // Remove previous listener first if script re-runs
                    // player.removeEventListener("ended", specificEndedHandler); // Need named handler or other mechanism
                    player.addEventListener("ended", function () {
                        // Use function to get correct 'this'
                        // Only act if the event is from the currentPlayerElement and not already swapping
                        if (this === currentPlayerElement && !this.isSwapping) {
                            console.log(
                                `[Event] 'ended' fallback triggered on current player ${this.id}.`,
                            );
                            handleAnticipatedVideoEnd.call(this); // Call the handler with correct context
                        } else if (
                            this === currentPlayerElement &&
                            this.isSwapping
                        ) {
                            console.log(
                                `[Event] 'ended' ignored on ${this.id} because swap is already in progress.`,
                            );
                        }
                    });

                    // --- NEW Timeupdate Listener ---
                    const ANTICIPATION_TIME = 0.5; // Seconds before the end to trigger swap
                    player.addEventListener("timeupdate", function () {
                        // Use function to get correct 'this'
                        // Only act if the event is from the currentPlayerElement, not already swapping, and close to the end
                        if (
                            this === currentPlayerElement &&
                            !this.isSwapping &&
                            this.duration > 0 &&
                            this.duration - this.currentTime <=
                                ANTICIPATION_TIME
                        ) {
                            console.log(
                                `[Event] 'timeupdate' anticipation triggered on current player ${this.id} at ${this.currentTime}/${this.duration}.`,
                            );
                            handleAnticipatedVideoEnd.call(this); // Call the handler with correct context
                        }
                    });
                },
            );

            // --- NEW Handler for Swap Trigger ---
            function handleAnticipatedVideoEnd() {
                // 'this' refers to the video element that triggered the event (currentPlayerElement)
                if (this.isSwapping) {
                    console.log(
                        `[Anticipate] Swap already in progress for ${this.id}. Ignoring trigger.`,
                    );
                    return; // Avoid redundant swaps
                }

                console.log(
                    `[Anticipate] Handling end/anticipation for ${this.id}. Audio ended: ${scenarioAudioElement.ended}`,
                );

                // Check if audio has finished - if so, stop everything
                if (
                    scenarioAudioElement.ended ||
                    !scenarioAudioElement.currentSrc
                ) {
                    console.log(
                        `[Anticipate] Audio ended or no source. Stopping playback.`,
                    );
                    stopPlaybackAndAudio();
                    return;
                }

                // Check if there are multiple videos to swap between
                if (currentVideoPlaylist.length <= 1) {
                    console.log(
                        "[Anticipate] Only one video or empty playlist, stopping.",
                    );
                    stopPlaybackAndAudio(); // Stop if only one video finishes or audio ends
                    return;
                }

                // Mark that a swap is now in progress for *this* video element
                this.isSwapping = true;
                console.log(
                    `[Anticipate] Setting isSwapping=true for ${this.id}`,
                );

                // Proceed to check the buffer and potentially swap
                checkBufferAndSwap();
            }

            // --- REFACTORED from handleVideoEndAndSwap ---
            function checkBufferAndSwap() {
                console.log(
                    `[CheckSwap] Checking buffer readiness. Index: ${currentVideoPlaybackIndex}. Buffer ready: ${isBufferVideoReady}`,
                );

                // Only proceed if the buffer video is ready
                if (!isBufferVideoReady) {
                    console.warn(
                        "[CheckSwap] Buffer video not ready yet! Playback might stutter.",
                    );
                    // Attempting swap anyway, browser might catch up.
                    // If this happens frequently, ANTICIPATION_TIME might be too short,
                    // or network/video files are problematic.
                    // We could potentially delay here, but that risks *causing* a stutter.
                    // Forcing the swap and hoping for the best might be smoother *most* of the time.
                    // Alternative: Stop playback if buffer isn't ready to prevent bad swap?
                    // stopPlaybackAndAudio();
                    // return;
                }

                // Buffer is ready (or we're proceeding anyway), perform the swap
                console.log(
                    "[CheckSwap] Buffer ready or forcing swap. Performing swap.",
                );
                performSwap();
            }

            // Removed - Now part of loadVideoIntoPlayer
            /*
            function attemptPlayAndSyncAudio(videoElementToPlay) {
                 // ... old implementation ...
                 if (scenarioAudioElement && !scenarioAudioElement.paused) {
                     scenarioAudioElement.pause();
                 }
                 isAudioPlaying = false;
                 // Keep hasAudioStarted as true if it was already started

                 // Reset swapping flags
                 scenarioVideoElement.isSwapping = false;
                 scenarioVideoBufferElement.isSwapping = false;
                 console.log("Reset swapping flags.");
            }
            */

            function attemptPlayVideo(videoElementToPlay) {
                // Only play if the source is valid
                if (!videoElementToPlay || !videoElementToPlay.currentSrc) {
                    console.warn(
                        "[PlayAttempt] Cannot play, invalid element or source.",
                        videoElementToPlay,
                    );
                    return;
                }
                // Don't try to play if already playing
                if (!videoElementToPlay.paused) {
                    console.log(
                        `[PlayAttempt] Video ${videoElementToPlay.id} is already playing.`,
                    );
                    return;
                }

                console.log(
                    `[PlayAttempt] Attempting to play video ${videoElementToPlay.id}`,
                );
                const playPromise = videoElementToPlay.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log(
                                `[PlayAttempt] Video ${videoElementToPlay.id} started playing successfully.`,
                            );
                            // syncAudioPlay will be called via the 'onplay' event handler
                        })
                        .catch((error) => {
                            console.error(
                                `[PlayAttempt] Error trying to play video ${videoElementToPlay.id}:`,
                                error,
                            );
                            // Common issue: User hasn't interacted yet.
                            if (error.name === "NotAllowedError") {
                                showError(
                                    "Playback requires user interaction. Click play on the video.",
                                );
                                // Ensure audio hasn't sneakily started
                                if (!scenarioAudioElement.paused)
                                    scenarioAudioElement.pause();
                                isAudioPlaying = false;
                            } else {
                                showError(
                                    `Error playing video: ${error.message}`,
                                );
                            }
                            // Stop everything if play fails critically
                            stopPlaybackAndAudio();
                        });
                }
            }

            // Removed - Integrated into loadVideoIntoPlayer
            /*
             // Universal 'canplay' event listener
             [scenarioVideoElement, scenarioVideoBufferElement].forEach(player => {
                player.addEventListener("canplay", () => {
                    // ... old implementation ...
                });
            });
            */

            // Synchronization logic refinement
            function syncAudioPlay() {
                // This function is triggered by the video's 'onplay' event.
                if (isSeeking) return; // Don't sync during seek operation

                console.log(
                    `[Sync] Video 'onplay' triggered on ${currentPlayerElement.id}. hasAudioStarted: ${hasAudioStarted}, isAudioPlaying: ${isAudioPlaying}, audioSrc: ${!!scenarioAudioElement.currentSrc}`,
                );

                // Check if audio should be playing
                if (scenarioAudioElement.currentSrc) {
                    if (!hasAudioStarted) {
                        // First time video plays (initiated by user click or auto-play after swap)
                        // This means it's the first play for THIS audio track in the current turn.
                        console.log(
                            "[Sync] Starting audio for the first time for this track.",
                        );
                        scenarioAudioElement.currentTime = 0; // Start this audio track from its beginning.
                        scenarioAudioElement
                            .play()
                            .then(() => {
                                hasAudioStarted = true;
                                isAudioPlaying = true;
                                console.log(
                                    "[Sync] Audio started successfully (first time for track).",
                                );
                            })
                            .catch((e) => {
                                console.error(
                                    "[Sync] Error starting audio (first time for track):",
                                    e,
                                );
                                stopPlaybackAndAudio();
                                showError("Could not start audio playback.");
                            });
                    } else if (scenarioAudioElement.paused) {
                        // Video was played (e.g., after pause or swap) and audio was paused, resume audio.
                        // Audio has been started before for this track, but is currently paused.
                        console.log("[Sync] Resuming paused audio.");
                        // DON'T set currentTime here. Let it resume from where it was paused.
                        scenarioAudioElement
                            .play()
                            .then(() => {
                                isAudioPlaying = true; // Audio is now playing
                                console.log(
                                    "[Sync] Audio resumed successfully.",
                                );
                            })
                            .catch((e) => {
                                console.error(
                                    "[Sync] Error resuming audio:",
                                    e,
                                );
                                stopPlaybackAndAudio();
                                showError("Could not resume audio playback.");
                            });
                    } else {
                        // Audio has started and is not paused. Video is playing.
                        // This means audio should already be playing. No action needed regarding currentTime.
                        // Ensure isAudioPlaying is true, as video play implies audio should be active.
                        isAudioPlaying = true;
                        console.log(
                            "[Sync] Audio is already started and not paused. Video playing.",
                        );
                    }
                } else {
                    console.log(
                        "[Sync] No audio source, video playing independently.",
                    );
                }
            }

            function syncAudioPause() {
                if (isSeeking) return; // Don't sync during seek operation

                // This function is triggered by the video's 'onpause' event.
                if (
                    scenarioAudioElement.currentSrc &&
                    !scenarioAudioElement.paused &&
                    currentPlayerElement &&
                    currentPlayerElement.paused
                ) {
                    console.log("[Sync] Video pause detected, pausing audio.");
                    scenarioAudioElement.pause();
                    isAudioPlaying = false; // Audio is now paused
                }
            }

            // Add 'seeking' and 'seeked' listeners to manage the isSeeking flag
            function handleVideoSeeking(videoElement) {
                // Accept videoElement as parameter
                if (videoElement === currentPlayerElement) {
                    isSeeking = true;
                    console.log("[Sync] Video seeking started.");
                    // Optionally pause audio during seek?
                    // if (!scenarioAudioElement.paused) scenarioAudioElement.pause();
                }
            }

            function handleVideoSeeked(videoElement) {
                // Accept videoElement as parameter
                if (videoElement === currentPlayerElement) {
                    console.log("[Sync] Video seeking finished.");
                    if (scenarioAudioElement.currentSrc && hasAudioStarted) {
                        console.log(
                            `[Sync] Video seeked. Current video time: ${videoElement.currentTime}. Audio continues from: ${scenarioAudioElement.currentTime}`,
                        );
                        // DO NOT sync audio time to video time after seek.
                        // scenarioAudioElement.currentTime = videoElement.currentTime; // REMOVED THIS LINE

                        // If video is playing after seek, ensure audio plays too
                        if (
                            !videoElement.paused &&
                            scenarioAudioElement.paused
                        ) {
                            console.log(
                                "[Sync] Resuming audio after seek (video is playing).",
                            );
                            scenarioAudioElement
                                .play()
                                .then(() => (isAudioPlaying = true))
                                .catch((e) =>
                                    console.error(
                                        "Error resuming audio post-seek:",
                                        e,
                                    ),
                                );
                        } else if (
                            videoElement.paused &&
                            !scenarioAudioElement.paused
                        ) {
                            // If video is paused after seek, pause audio too
                            console.log(
                                "[Sync] Pausing audio after seek (video is paused).",
                            );
                            scenarioAudioElement.pause();
                            isAudioPlaying = false;
                        }
                    }
                    // Crucially, reset the flag *after* adjustments
                    setTimeout(() => {
                        isSeeking = false;
                    }, 50); // Small delay before resetting flag
                }
            }

            [scenarioVideoElement, scenarioVideoBufferElement].forEach(
                (player) => {
                    // Remove old listeners if script re-runs
                    // player.removeEventListener('play', ...)
                    // ... etc

                    player.onplay = function () {
                        // 'this' is the player
                        if (this === currentPlayerElement) syncAudioPlay();
                    };
                    player.onpause = function () {
                        // 'this' is the player
                        if (this === currentPlayerElement) syncAudioPause();
                    };
                    player.onseeking = function () {
                        // 'this' is the player
                        handleVideoSeeking(this); // Pass 'this' (the player element)
                    };
                    player.onseeked = function () {
                        // 'this' is the player
                        handleVideoSeeked(this); // Pass 'this' (the player element)
                    };
                },
            );

            // Handle audio ending - it should stop video playback
            scenarioAudioElement.onended = () => {
                console.log("[Sync] Audio track has ended.");
                isAudioPlaying = false;
                // hasAudioStarted remains true

                // Pause the current video when audio ends
                if (currentPlayerElement && !currentPlayerElement.paused) {
                    console.log(
                        "[Sync] Pausing current video because audio ended.",
                    );
                    currentPlayerElement.pause();
                }
                // Ensure buffer is also paused if it somehow got playing
                if (bufferPlayerElement && !bufferPlayerElement.paused) {
                    bufferPlayerElement.pause();
                }
            };
            // --- END NEW FUNCTIONS AND EVENT LISTENERS ---

            // Render developer logs
            function renderDeveloperLogs(logs, turnNumber) {
                // Create a container for the logs if it doesn't exist
                const logsContainerId = `logs-turn-${turnNumber}`;
                let logsContainer = document.getElementById(logsContainerId);

                if (!logsContainer) {
                    // Create a new panel for this turn's logs
                    const panel = document.createElement("div");
                    panel.className = "developer-panel";
                    panel.style.display = developerMode ? "block" : "none";

                    // Create the header
                    const header = document.createElement("div");
                    header.className = "developer-header";
                    header.innerHTML = `
                    <h4>LLM Interactions - Turn ${turnNumber}</h4>
                    <span class="expand-arrow"></span>
                `;

                    // Create the logs container
                    logsContainer = document.createElement("div");
                    logsContainer.className = "logs-container";
                    logsContainer.id = logsContainerId;

                    // Add click handler to toggle expansion
                    header.addEventListener("click", () => {
                        header.classList.toggle("expanded");
                        logsContainer.style.display = header.classList.contains(
                            "expanded",
                        )
                            ? "block"
                            : "none";
                    });

                    // Assemble the panel
                    panel.appendChild(header);
                    panel.appendChild(logsContainer);

                    // Add to the DOM before the response form
                    developerLogsElement.appendChild(panel);
                } else {
                    // Clear existing logs
                    logsContainer.innerHTML = "";
                }

                // Add each log entry
                logs.forEach((log) => {
                    const logEntry = document.createElement("div");
                    logEntry.className = "log-entry";

                    // Create operation header with timestamp and response time
                    const timestamp = new Date(
                        log.timestamp,
                    ).toLocaleTimeString();
                    const responseTime = log.response_time_seconds
                        ? `<span class="response-time">${log.response_time_seconds.toFixed(2)}s</span>`
                        : "";

                    logEntry.innerHTML = `
                    <h5>
                        <span class="badge">${log.operation_name}</span>
                        <small>${timestamp}</small>
                        <small>${log.model_name}</small>
                        ${responseTime}
                    </h5>
                `;

                    // Add prompt
                    const promptPre = document.createElement("pre");
                    promptPre.className = "prompt";
                    promptPre.textContent = log.prompt;

                    // Add completion
                    const completionPre = document.createElement("pre");
                    completionPre.className = "completion";
                    completionPre.textContent = log.completion;

                    // Add parameters
                    const paramsPre = document.createElement("pre");
                    paramsPre.className = "params";
                    paramsPre.textContent = JSON.stringify(
                        log.parameters,
                        null,
                        2,
                    );

                    // Assemble the log entry
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Prompt:";
                    logEntry.appendChild(promptPre);
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Completion:";
                    logEntry.appendChild(completionPre);
                    logEntry.appendChild(
                        document.createElement("strong"),
                    ).textContent = "Parameters:";
                    logEntry.appendChild(paramsPre);

                    // Add to the container
                    logsContainer.appendChild(logEntry);
                });
            }

            // Show error message
            function showError(message) {
                errorElement.textContent = message;
                errorElement.style.display = "block";

                // Log additional details in console when in developer mode
                if (developerMode) {
                    console.warn("Developer mode error details:", message);

                    // Add more detailed error to UI in developer mode
                    const errorDetailsElement = document.createElement("pre");
                    errorDetailsElement.className = "error-details";
                    errorDetailsElement.textContent = JSON.stringify(
                        {
                            timestamp: new Date().toISOString(),
                            message: message,
                            simulation_id: simulationId,
                            turn: currentSimulation
                                ? currentSimulation.current_turn_number
                                : "unknown",
                        },
                        null,
                        2,
                    );

                    // Only append if there isn't already an error-details element
                    if (!document.querySelector(".error-details")) {
                        errorElement.appendChild(errorDetailsElement);
                    }
                }

                // Auto-hide error after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = "none";
                    // Clear any error details
                    const errorDetails =
                        errorElement.querySelector(".error-details");
                    if (errorDetails) {
                        errorDetails.remove();
                    }
                }, 10000);
            }

            // Functions to handle generation progress indicators
            function resetProgressIndicators() {
                console.log("Resetting progress indicators");
                // Reset scenario progress
                document.getElementById("scenario-progress-icon").textContent =
                    "...";
                document
                    .getElementById("scenario-progress-icon")
                    .classList.remove("complete");
                document
                    .getElementById("scenario-progress-icon")
                    .classList.add("pending");
                document.getElementById(
                    "scenario-progress-status",
                ).textContent = "Pending";
                document
                    .getElementById("scenario-progress-status")
                    .classList.remove("complete");

                // Reset videos progress
                document.getElementById("videos-progress-icon").textContent =
                    "...";
                document
                    .getElementById("videos-progress-icon")
                    .classList.remove("complete");
                document
                    .getElementById("videos-progress-icon")
                    .classList.add("pending");
                document.getElementById("videos-progress-status").textContent =
                    "Pending";
                document
                    .getElementById("videos-progress-status")
                    .classList.remove("complete");

                // Reset audio progress
                document.getElementById("audio-progress-icon").textContent =
                    "...";
                document
                    .getElementById("audio-progress-icon")
                    .classList.remove("complete");
                document
                    .getElementById("audio-progress-icon")
                    .classList.add("pending");
                document.getElementById("audio-progress-status").textContent =
                    "Pending";
                document
                    .getElementById("audio-progress-status")
                    .classList.remove("complete");
            }

            function markProgressComplete(type) {
                console.log(`Marking progress complete for: ${type}`);
                const icon = document.getElementById(`${type}-progress-icon`);
                const status = document.getElementById(
                    `${type}-progress-status`,
                );

                if (icon && status) {
                    icon.textContent = "";
                    icon.classList.remove("pending");
                    icon.classList.add("complete");
                    status.textContent = "Complete";
                    status.classList.add("complete");
                    console.log(
                        `Progress updated for ${type}: icon=${icon.textContent}, status=${status.textContent}`,
                    );
                } else {
                    console.error(
                        `Could not find elements for ${type} progress indicator`,
                    );
                }
            }

            // Function to cleanly stop playback
            function stopPlaybackAndAudio() {
                console.log("Stopping video and audio playback.");
                if (currentPlayerElement && !currentPlayerElement.paused) {
                    currentPlayerElement.pause();
                }
                if (bufferPlayerElement && !bufferPlayerElement.paused) {
                    bufferPlayerElement.pause();
                }
                if (scenarioAudioElement && !scenarioAudioElement.paused) {
                    scenarioAudioElement.pause();
                }
                isAudioPlaying = false;
                // Keep hasAudioStarted as true if it was already started
            }

            // Initialize the UI on page load
            initUI();
            console.log("SCRIPT EXECUTION TEST AT BOTTOM");
        </script>
    </body>
</html>
